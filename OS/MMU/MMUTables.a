;
;	File:		MMUTables.a
;
;	Contains:	MMU setup and manipulation routines
;
;	Written by:	Bob Herold
;
;	Copyright:	© 1986-1993 by Apple Computer, Inc.  All rights reserved.
;
;	Change History (most recent first):
;
;	  <SM23>	12/13/93	PN		Roll in KAOs and Horror changes to support Malcom and AJ
;									machines.
;	  <SM22>	11/12/93	SAM		Roll in <MC3> from mc900ftjesus.
;	   <MC3>	11/12/93	SAM		For EMMU machines get the EDisk size from beyond the chunk table
;									(see SizeMem for details).
;	  <SM21>	11/10/93	fau		Update from SuperMunggio <SMG2>.
;	  <SMG2>	 8/27/93	fau		Added a HHead entry to the table of decoders.
;	  <SM20>	11/10/93	SAM		Roll in <MC2> from mc900ftjesus.
;	   <MC2>	11/10/93	SAM		We now enforce the upper limit top the EDisk.  Currently its set
;									to 255 MB.
;	  <SM19>	 3/31/93	chp		Synchronize SuperMario with changes from <LW2>. Also modify
;									early universal test for has68kEmulator: the constant for this
;									test must be modulo 8 and it is the individual's responsibility
;									to look in the correct byte (TestFor is not available yet).
;	  <SM18>	 3/11/93	SAM		Added a flag to bootGlobs that tell this code whether or not to
;									steal chunks of RAM for the EDisk.  Added code to check that
;									flag (sgEDiskStealFlag) instead of sgEDiskSize.
;	   <LW2>	 2/26/93	fau		Removed MMC support and changed all names including MMC to YMCA.
;	  <SM17>	  2/5/93	SAM		Added support for emulated MMUs.
;	  <SM16>	12/23/92	RC		Added Support for Smurf on Wombat
;	  <SM15>	12/18/92	RB		Updated the MSC MMUTables from Horror, since it was wrong.
;	  <SM14>	 12/1/92	EH		Added tables and code for Pratt Memory controller.
;	  <SM13>	11/13/92	rab		Roll in Horror changes. Comments follow:
;	  	  <H32>	10/23/92	BG		Changed MinBootGlobs to fix the Quadra 9x0 256MB + RAM Disk
;									problem.
;	      <H31>	 9/11/92	JC		Conditionally add support for an 040 board on Vail.
;	      <H30>	 8/10/92	NJV		Added Double-Exposure support for Sonora 3.0.
;	      <H29>	 7/24/92	NJV		Fixed 2 ReAnimator bugs where addresses were being doubly
;									corrected.
;	      <H28>	 7/15/92	SWC		Put the sound buffer size into the 24- and 32-bit size fields in
;									its entry in the physical space table since VM was getting
;									confused.
;	      <H27>	 7/13/92	SWC		Moved the code to move the RAM chunk table below a sound buffer
;									(SkipSoundBuffer) to SizeMemPatch.a since when it was here, the
;									warmstart flag would get trashed and so would the RAM disk.
;	      <H25>	  7/6/92	SWC		Fixed a couple of bugs in SkipSoundBuffer. If a sound buffer is
;									present, we'll separate it out from other RAM in the physical
;									space table so VM won't use it for paging.
;	      <H23>	 6/23/92	SWC		Modified MSC tables to use full page tables. Modified Dart's MMU
;									tables to use the same setup (needed to tweak things a bit). Use
;									TT0 for DBLite and Dartanian LCD video (we both use the same
;									hardware), and TT1 for DBLite's slot space. Added a new routine,
;									SkipSoundBuffer, to move the RAM chunk table down if there is a
;									sound buffer in high RAM. Use a common equate, b32VidBase, to
;									specify the base of a non-RBV video frame buffer (MSC and Sonora
;									versions went away) since that part of the address space is
;									supposed to be reserved for just that purpose.
;	      <H22>	  6/3/92	HY		Change ROM space for LC/Slice to 4mb. DblX slot space now 64k
;									and the rest of I/O space is now mapped straight thru.
;									Removed all mappings in MMU templates/physical templates for 
;									on-board video. Remove routine GetVisaSize (we don't support 
;									on-board video, so not needed). Add MMU entry for RAM disk. 
;	      <H20>	 5/28/92	BG		Added Wombat memory information.  As far as MMUs and memory
;									mapping, it should look exactly the same as Orwell (Q700/9x0).
;	  <SM12>	11/10/92	GD		Rolled in Niagra (for PowerBook) tables from Horror. Also fixed
;									a "forRomulator" build issue.
;	  <SM11>	 11/3/92	RB		Changed the use of LC930 in the 24 bit mode support test to
;									Supports24Bit
;	  <SM10>	10/30/92	RB		On the LC930, do not force 32 bit mode, since it supports 24 bit
;									mode.
;	   <SM9>	10/22/92	HY		Change MMU tables for LC II/930 to support PDS flash. Also
;									remove onboard video support, add EDisk entry, and reduce
;									DblX range from 256k to 64k. Increase ROM size from 2 to 4Mb.
;	   <SM8>	10/18/92	CCH		Added support for PDM and removed padding at the end.
;	   <SM7>	 9/30/92	fau		Added support for the new Cyclone EVT4 decoder, YMCA.  It uses
;									the same tables as the MMC, but it is a new entry in the
;									DecoderKinds record.
;	   <SM6>	08/19/92	CSS		BootGlobs was changed to StartGlobals by DTY in Reality and this file
;									needs changing, also.
;	   <SM5>	08/11/92	jmp		Added ReAnimator support for '030 machines (taken straight from
;									Horror).
;	   <SM4>	  8/9/92	CCH		Added ReAnimator™ support for HMMU-based machines, and allow
;									Orwell-based machines to have HMMUs.
;	   <SM3>	 7/13/92	CCH		Added conditionalized support for Cub Cards on Quadra 700.
;		<SM1>	 5/26/92	CSS		Cyclone roll in.;	   
;									<P13> 5/13/92 KW	(HV,H18) Roll-in LC II changes.  Add MMU templates for LC II,
;														modify InitMMU routine so that the exception vector table
;														contains logical instead of physical addresses, modify @VISA
;														routine to load up A0 and A1 with MMU templates, and modified
;														routine doPhysROM to build the ROM entries according to the way
;														the physical templates are defined if the ROM physical size is
;														not 256mb.
;														(HJR,H17) Modified Niagra MMU Templates so that part of ROM is
;														mapped to the end of Slot E space.  This is in order to fake the
;														Slot Manager into using part of the Main rom as the config ROM.
;														It is necessary that if the location of VSCDeclData moves that
;														the corresponding MMU Tables be updated.  Updated physNiagra
;														space table.
;	   								<P12> 4/24/92	KW	(JC,H16) Cleaned up Sonora Physical Space Tables.
;	   								<P11> 4/16/92	KW	(JC, H15)  Cleaned up Sonora tables.
;														(SWC, H14)	Mucked around a bit more with the MSC tables.
;	   								<P10> 04/16/92 jmp	Replaced some hard-coded values with defined constants.
;									<P9>  04/08/92 jmp	Updated the physMMC table entries to more accurate reflect
;														reality (I think).
;									<P8>  03/22/92 jmp	Removed the 'isVoid' mappings for Slots A&B for MMC in 24-bit
;														mode.
;									<P7>   2/25/92 RMP	Modified the 32-Bit MMC table to map in CIVIC register set and
;														VRAM.
;									<P6>  02/07/92 jmp	(SWC,H13) Added entries to the MSC tables for slots C and D,
;														which are available when DBLite is plugged into its docking
;														station.
;														(JC,H12) Add support for optionally using full page tables on
;														030 machines, modify Sonora Tables, and add support for
;														alternate physical ROM address as defined in Universal Tables.
;														(JC,H11) Change to fix Spike problem on Non Sonora builds.
;														(JC,H10) Add support for Double Exposure for Vail as it was done
;														on Foster Farms, and added support for the alternate ROM
;														physical address defined in Universal Tables.
;									<P5>  1/23/92 RMP	Hand map slot 9 for MMC table in 24 bit mode (is 2nd half of
;									2-Meg ROM).
;									<P4>  1/22/92 RMP	Added MMC support.  Added MMC tables.
;									<P3> 01/13/92 jmp	(SWC,H9) Turned off caching for video space for DB-Lite to get
;														around a bug with the GSC.
;									<P2>  1/4/92  RP	Changed ROMMaxSize for 2-Meg ROM
;		 <1>	 5/17/92	kc		first checked in
;	   <SM0>	 3/26/92	kc		Rolled in from Horror. Comments follow.
;                                   Force 32-bit mode. (see <SM7> in MemoryMgr.a)                   
;									•••• This should be backed out as soon as we carve out space for
;									the 2 Meg rom from the slot address space. ••••
;	   <H17>	 4/24/92	HJR		Modified Niagra MMU Templates so that part of ROM is mapped to
;									the end of Slot E space.  This is in order to fake the Slot
;									Manager into using part of the Main rom as the config ROM.  It
;									is necessary that if the location of VSCDeclData moves that the
;									corresponding MMU Tables be updated.  Updated physNiagra space
;									table.
;	   <H16>	 4/19/92	JC		Cleaned up Sonora Physical Space Tables.
;	   <H15>	 4/13/92	JC		Cleaned up Sonora tables.
;	   <H14>	 4/10/92	SWC		Mucked around a bit more with the MSC tables.
;	   <H13>	 1/31/92	SWC		Added entries to the MSC tables for slots C and D, which are
;									available when DBLite is plugged into its docking station.
;	   <H12>	 1/24/92	JC		Add support for optionally using full page tables on 030
;									machines, modify Sonora Tables, and add support for alternate
;									physical ROM address as defined in Universal Tables.
;	   <H11>	 1/22/92	JC		Change to fix Spike problem on Non Sonora builds.
;	   <H10>	 1/20/92	JC		Add support for Double Exposure for Vail as it was done on
;									Foster Farms, and added support for the alternate ROM physical
;									address defined in Universal Tables.
;		<H9>	  1/6/92	SWC		Turned off caching for video space for DB-Lite to get around a
;									bug with the GSC.
;		<H8>	12/16/91	HJR		Added NiagraTables for Dartanian.
;		<H7>	12/13/91	SWC		Removed video wrap space from MSC tables since the CPU ID
;									register is directly below the LCD frame buffer so we won't have
;									any QuickDraw gotchas.
;		<H6>	12/12/91	CCH		Reverted back to making Edisk space uncacheable when VM is on.
;		<H5>	 12/3/91	SWC		Added MSCVidWrap to specify the video wrap and display size for
;									DB-Lite since its LCD display supports grayscale (and hence more
;									VRAM).
;		<H4>	11/25/91	CCH		Added Sonora support.
;		<H3>	11/14/91	jmp		(CCH) Mark EDisk address space as cacheable in physical space
;									table.
;		<H2>	10/15/91	SWC		Changed BSR to PRamIO to a BSR.L since PRamIO moved from
;									ClockPatch.a to Clock.a.
; ———————————————————————————————————————————————————————————————————————————————————————
;	  Pre-HORROR ROM comments begin here.
; ———————————————————————————————————————————————————————————————————————————————————————
;		<25>	  7/8/91	CCH		Bumped padding size.
;		<24>	 6/26/91	CCH		Moved RAM disk to slot 7 space.
;		<23>	 6/25/91	CCH		Fixed a bug in HandleTrailing and WriteTableNode for levels that
;									contain no valid descriptors. Increased Max Ram disk size to 256
;									meg. Added Ram disk support to all machines and changed Ram disk
;									address space to slot 6 space.
;		<22>	 6/21/91	BG		Swapped the order of the case table in FindInfo to match the
;									(new) order of the DecoderKinds table in UniversalEqu.a.
;		<21>	 6/13/91	CCH		Moved bRamDisk equate to EDiskEqu.a, and changed RAM disk
;									address location.
;		<20>	 6/11/91	CCH		Created a nonserialized image of i/o space just above existing
;									space on Orwell-based machines and made slot 9 minor slot space
;									non-serialized.
;		<19>	 5/31/91	djw		Added jump table entries and MMU tables to support DBLite/MSC.
;		<18>	 5/23/91	CCH		Fixed a bug in WriteTableNode that wrote out page descriptors in
;									the intermediate table when it encountered an entire level of
;									invalid descriptors.  Also modified the Jaws template to take
;									advantage of early termination descriptors.
;		<17>	  5/9/91	HJR		Set VRAMrealSize to LCDMaxSize in the Jaws case in FindInfo and
;									removed the Slot $E entry in physical space table since make
;									physical set that area to be onboard video.
;		<16>	  5/9/91	CCH		Removed slot $B mapping from 24-bit Jaws template.
;		<15>	 4/21/91	CCH		Turned on copyback mode at boot on 68040's. Modified Jaws
;									template to add ramdisk support for Tim. Also fixed a bug in
;									HandlerTrailing which screwed up when all pages in a subtable
;									were invalid.
;		<14>	  4/5/91	CCH		Added slot 9 minor slot space for Orwell machines as
;									kUsageOnboardVideo in physical space table.
;		<13>	 3/29/91	CCH		Removed slot 9 entry from Orwell physical space tables.
;		<12>	 3/19/91	CCH		Turned off full-tables for non-68040 machines.
;		<11>	 3/19/91	CCH		Added modifications to have the MMU create a seperate ram disk
;									area to allow bootable RAM disks under VM and on machines with
;									non-contiguous memory architectures. Also turned on full page
;									tables on 030 machines.
;		<10>	  3/5/91	BG		Fixed a typo in Template24RBVe. Slot B was mapped to Slot 9.
;		 <9>	 2/18/91	HJR		Fix commenting error.
;		 <8>	 2/18/91	HJR		Corrected physical space table for physLCD.  VM now works on
;									Tim.
;		 <7>	  2/4/91	CCH		Added physical space table for Orwell based machines.
;		 <6>	 1/14/91	CCH		Exported Trans.
;		 <5>	12/20/90	CCH		Changed stack initialization to used fixed value.
;		 <4>	10/25/90	CCH		Added support for ReAnimator when forRomulator equate is set.
;		 <3>	 10/2/90	CCH		Added padding at the end of the file.
;		 <2>	  9/9/90	CCH		Moved this file into second half-meg of ROM, and rolled in
;									Eclipse and Tim support.
; ———————————————————————————————————————————————————————————————————————————————————————
;	  Pre-Terror ROM comments begin here.
; ———————————————————————————————————————————————————————————————————————————————————————
;		 <3>	 6/12/90	JJ		Add support for Apple II emulation video modes.  Rolled in
;									changes from main project.  Original comments follow.
;		{14}	  6/7/90	CCH		Ensured that only 24 bits are compared in the 24-bit logical
;									video base address when determining which slot to use for video.
;		 <2>	 5/14/90	CV		Fixed mistake in last rev.
;		 <1>	 5/14/90	CV		This file was originally part of MMU.a.  It contains the MMU
;									tables.  The files were split because the addition of code to
;									support video in slot E made the file grow beyond the space
;									allocated in MMU.a.
;	To Do:
;
;	implement lower limits (bell & whistle...)


			PRINT		OFF
			LOAD		'StandardEqu.d'
			INCLUDE		'HardwarePrivateEqu.a'
			INCLUDE		'MMUEqu.a'
			INCLUDE		'BootEqu.a'
			INCLUDE		'UniversalEqu.a'
			INCLUDE		'EdiskEqu.a'
			PRINT		ON

			MACHINE		MC68030
MMUStuff	PROC
			EXPORT		InitMMU
			IMPORT		BaseOfROM, Critical, PramIO, RamTest
			IMPORT		RomLoc
			IMPORT		SizeSoundBuffer

			WITH 		StartGlobals
			WITH 		MMUConfigInfo

;-----
;   The following table give MMU setup information for the different memory controllers
;   and their associate memory models (contiguous, split, weird with RBV onboard video).
;	Some extra entries have been provide for future overpatches.
;
;	The Splitxxmb32 entries are for split memory model machines (such as the MDU without
;	onboard video).  The xx is the size of the smallest RAM chunk.  We can set up early 
;	termination entries to match the smallest RAM chunk size, and thereby make the table
;	smaller when we have larger RAM chunks.
;
;	Include in each table entry is the TC (translation control register), the two 
;	translation register values to use, an offset to a template describing how to map 
;	the logical address space, an offset to a special template (see next paragraph) and
;	an offset to a 'physical table' template.
;
;	The special template can be used to create a huge void in the logical space above low 
;	memory and start the system heap right below the ROM.  This is useful for stress-testing
;	32 bit addressing.  The special template is used when the appropriate parameter RAM bit 
;	is set.
;---

MMUSetupInfo	RECORD	0,INCR
newtc			ds.l	1		; translation control register
newtt0			ds.l	1		; transparent translation reg 0
newtt1			ds.l	1		; transparent translation reg 1
templOff		ds.w	1		; offset to template
specialOff		ds.w	1		; offset to special template
physicalOff		ds.w	1		; offset to template for physical space
size			equ		*		; size of each table entry
				ENDR
			
			WITH	MMUSetupInfo

;-----
;	The template tables describe the logical to physical address mapping.  
;
;	Eech entry has a size of a chunk of the logical space, a suggested physical address for
;	the chunk, a type and a cache inhibit flag.  The size and physical address fields are
;	long sized. The suggested physical address often is mostly used for the 24 bit mode case.
;
;	The type and cache inhibit flags are imbedded in the low order 4 bits of the suggested
;	physical address word, as follows:
;
;		bits 3,2,1,0 - template type, describes how to map these addresses as follows:
;
;			0000 - map the logical address straight thru
;			0001 - a RAM entry.  Map to pages of RAM allocated from the chunks found by Starttest.
;			0010 - a ROM entry for 32 bit mode.  Use either the hardware defined physical
;				  address of the ROM, or the base of the ROM image if it is running in RAM.
;			0011 - a ROM entry for 24 bit mode.  Use either a 24 bit compatible version of the
;				  hardware address of the ROM, or the base of the ROM image running in RAM.
;			0100 - hack for a quickdraw bug: map to the end of the onboard video buffer
;				  This is used to map addresses immediately below the buffer to someplace
;				  that won;t cause bus errors, cuz quickdraw sometimes acceses there.
;			0101 - a video entry. Map to onboard video buffer (at physical zero for RBV)
;			0110 - use the specific address specified in the template.
;			0111 - map the address as invalid - this space will be a void in the middle of
;			      real RAM
;			1000 - 24-bit mode wrap area.  This is used on processors that don't have an
;				  initial-shift feature (i.e. 68040).
;
;		bit 5 - cache inhibit flag (1 means inhibit the cache, i.e. uncacheable)
;
;		bit 4 - 68040 cache mode.  This is the second bit in the cache mode for a 68040.  Bit 5
;				is the first bit and still indicates if the cache is inhibited.  If the cache
;				is on, this bit means 1=CopyBack, 0=Writethrough.  If the cache is inhibited, this
;				bit means 1=Non Serialized, 0=Serialized.
;
;		bit 6 - 0 = use early termination  of MMU Tables for this block.  
;				1 = map full pages for this block
;
;---

;-----
;	Equates defining the logical address space
;---

k8Size		equ		$00002000				; 8K
k32Size		equ		$00008000				; 32K
k128Size	equ		k32Size*4				; 128K
k512Size	equ		k128Size*4				; 512K
DeclRomSize	equ		$A0000					; Fake DeclData Rom size
DeclRomSz	equ		k128Size				; Fake DeclDate Rom size for super mario

ROMMaxSize	equ		$00200000				; 2M: size of largest possible ROM <SM1> CSS 				; <T7>
IOMaxSize	equ		$00040000				; 256k: max size of memory-mapped I/O space		; <7>
EDskMaxSize	equ		$10000000				; 256M: size of largest possible RAM disk		; <T23>
VRAMMaxSize	equ		$00200000				; 2M: size of largest possible VRAM <SM1> CSS 


VidWrapSize	equ		k32Size					; size of area before frame buffer to map to
											; start of frame buffer.  Fixes a Quickdraw bug.
											; NOTE: must be multiple of page size

RBVMaxSize	equ		$F8000					; maximum frame buffer size for RBV.
LCDMaxSize	equ		k32Size					; maximum frame buffer size for Waimea LCD.			<9>
											; NOTE: must be multiple of page size
											
			_AssumeEq	$100000, VidWrapSize+RBVMaxSize ; total video area must be 1 mb, or
														; template below must change
											
RBVBase32b	equ		$FBB08000				; 32 bit mode base of logical RBV frame buffer in slot B	<11>
RBVWrap32b	equ		RBVBase32b-VidWrapSize	; 32 bit mode address of wrap area
RBVEnd32b	equ		RBVBase32b + RBVMaxSize	; 32 bit mode end frame buffer address

			_AssumeEq	0, RBVWrap32b<<12	; RBV Wrap must be on 1MB boundary, or
											; template below must change
			_AssumeEq	0, RBVEnd32b<<12	; end of frame buffer must be on 1MB boundary, or
											; template below must change

RBVBase32e	equ		$FEE08000				; 32 bit mode base of logical RBV frame buffer in slot E	<11>
RBVWrap32e	equ		RBVBase32e-VidWrapSize	; 32 bit mode address of wrap area
RBVEnd32e	equ		RBVBase32e + RBVMaxSize	; 32 bit mode end frame buffer address

			_AssumeEq	0, RBVWrap32e<<12	; RBV Wrap must be on 1MB boundary, or
											; template below must change
			_AssumeEq	0, RBVEnd32e<<12	; end of frame buffer must be on 1MB boundary, or
											; template below must change

LCDBase32	equ		$FEE08000				; 32 bit mode base of logical video frame buffer	<9>
LCDWrap32	equ		LCDBase32-VidWrapSize	; 32 bit mode address of wrap area					<9>
LCDEnd32	equ		LCDBase32 + LCDMaxSize	; 32 bit mode end frame buffer address				<9>

			_AssumeEq	0, LCDWrap32<<12	; LCD Wrap must be on 1MB boundary, or
											; template below must change

RBVBase24b	equ		(RBVBase32b<<8)>>8		; 24 bit mode base of logical RBV frame buffer in slot B	<11>
RBVWrap24b	equ		RBVBase24b-VidWrapSize	; 24 bit mode address of wrap area
RBVEnd24b	equ		RBVBase24b + RBVMaxSize	; 24 bit mode end frame buffer address

RBVBase24e	equ		(RBVBase32e<<8)>>8		; 24 bit mode base of logical RBV frame buffer in slot E	<11>
RBVWrap24e	equ		RBVBase24e-VidWrapSize	; 24 bit mode address of wrap area
RBVEnd24e	equ		RBVBase24e + RBVMaxSize	; 24 bit mode end frame buffer address

LCDBase24	equ		(LCDBase32<<8)>>8		; 24 bit mode base of logical video frame buffer
LCDWrap24	equ		LCDBase24-VidWrapSize	; 24 bit mode address of wrap area
LCDEnd24	equ		LCDBase24 + LCDMaxSize	; 24 bit mode end frame buffer address

MSCVidBase	EQU		$60000000				; base of built-in frame buffer (not RBV)	<t19>
MSCVidEnd	EQU		$70000000				; end of frame buffer						<t19>

SonoraVidBase	EQU		$60000000			; base of built-in frame buffer (not RBV)	<H12>
SonoraVidEnd	EQU		$70000000			; end of frame buffer						<H12><H15>


bRam		equ		$0						; base of RAM area
bRom24		equ		$00800000				; base of ROM area (24 bit mode)
bEyeOh24	equ		$00F00000				; base of I/O area (24 bit mode)
b24Slot9	equ		$00900000				; base of minor slot 9 (24 bit mode)
b24SlotA	equ		$00A00000				; base of minor slot A (24 bit mode)
b24SlotB	equ		$00B00000				; base of minor slot B (24 bit mode)
b24SlotC	equ		$00C00000				; base of minor slot C (24 bit mode)
b24SlotD	equ		$00D00000				; base of minor slot D (24 bit mode)
b24SlotE	equ		$00E00000				; base of minor slot E (24 bit mode)
t24SlotE	equ		$00F00000				; top of minor slot E (24 bit mode)			<SM1> CSS <H18>
b24DblX		equ		$00FC0000				; base of Dbl X 24 bit Slot Space on Sonora	<H10>
bTop24Less1	equ		$00FFFFFF				; top of address space, less 1 (24 bit mode)

bRom32		equ		$40000000				; base of ROM area (32 bit mode)
bRealRom32	equ		$40800000				; exact base of ROM area (32 bit mode)		<7>
bEyeOh32	equ		$50000000				; base of I/O area (32 bit mode)
bVideo32	equ		$50036000				; base of video I/O area (32 bit mode)		<SM1> CSS <P7>
bVRAM32		equ		$50100000				; base of VRAM on Cyclone (32 bit mode)		<SM1> CSS <P7>
bRealEyeOh32 equ	$50F00000				; exact base of I/O area (32 bit mode)		<7>
bNonSerEyeOh equ	$50F40000				; base of non-serialized I/O area (32 bit)	<T20>
bNonSerIO	equ		$51000000				; base of non-serialized I/0 area (32 bit)
b32VidBase	equ		$60000000				; base of built-in frame buffer (not RBV)	<SM12>
b32Slot9	equ		$F9000000				; base of minor slot 9 (32 bit mode)
b32SlotA	equ		$FA000000				; base of minor slot A (32 bit mode)
b32SlotB	equ		$FB000000				; base of minor slot B (32 bit mode)
b32SlotC	equ		$FC000000				; base of minor slot C (32 bit mode)
b32SlotD	equ		$FD000000				; base of minor slot D (32 bit mode)
b32SlotE	equ		$FE000000				; base of minor slot E (32 bit mode)
b32SlotF	equ		$FF000000				; base of minor slot F (32 bit mode)  DO NOT USE!!!
bTop32Less1	equ		$FFFFFFFF				; top of address space, minus 1 (32 bit mode)


;---
;	Equates for Foster Farms templates	 <SM1> CSS														
;---

FFRomMax		equ		$400000					; 4 Mb of ROM space								<H18><Begin><SM9>
FFIOMax			equ		$C0000					; Max I/O space									
FFVideoMax		equ		$10000					; 64k max for video buffer						
FFbPhysVideo	equ		$9F0000					; physical base for on-board video				
DblXSlotMax		equ		$10000					; maximum size of double X slot space			<SM9>			

FFbShadow		equ		$00800000				; base of shadowed memory 						<SM13>
FFtShadow		equ		$00A00000				; top of shadowed memory						<SM13>

FFbRom24		equ		$00A00000				; base of FF ROM (24 bit mode)					<SM9>
FFtRom24		equ		FFbRom24+FFRomMax		; end of FF ROM (24 bit mode)					<SM9>

FFbRom32		equ		$40A00000				; base of FF ROM area (32 bit mode)
FFtRom32		equ		FFbRom32+FFRomMax
FFbEyeOh24		equ		$00F00000				; Beginning of I/O space (24 bit mode)			
FFtEyeOh24		equ		FFbEyeOh24+FFIOMax		; End of I/O space (24 bit mode)				
FFbEyeOh32		equ		$50F00000				; Beginning of I/O space (32 bit mode)
FFtEyeOh32		equ		FFbEyeOh32+FFIOMax		; End of I/O space (32 bit mode)

FFtDblxSlot24	equ		FFtEyeOh24+DblXSlotMax	; Top of Double Exposure slot space (24 bit)	<SM9>
FFtDblXSlot32	equ		FFtEyeOh32+DblXSlotMax	; Top of Double Exposure slot space				<H18><End>


;---
;	Equates for building and accessing the template
;---

typeMask		equ		$0000000F			; mask to get type bits						<7>
cBitMask		equ		$00000020			; mask to get cache inhibit bit				<7>
c040ModeMask	equ		$00000030			; mask to get cache mode bits for 68040		<7>
physMask		equ		$FFFF0000			; mask to get suggested physical address	<7>
FullTblMask		equ		$00000040			; mask to get full vs early termination field <H12>

;	Values for the 68040 Cache Mode field												<16>

c040CacheField		equ	4						; lsb of 68040 cache mode bits			<16>
c040WriteThru		equ	(0 << c040CacheField)	; cacheable, writethrough				<16>
c040CopyBack		equ	(1 << c040CacheField)	; cacheable, copyback					<16>
c040InhibitSer		equ	(2 << c040CacheField)	; cache inhibited, serialized writes	<16>
c040InhibitNonSer	equ	(3 << c040CacheField)	; cache inhibited, non-serialized writes<16>

cBitNum			equ		5					; bit number of cache inhibit flag			<7>
cInhibit		equ		cBitMask			; flag for inhibiting cache

isThru			equ		0					; type = 0000: logical address = physical address
isRam			equ		1					; type = 0001: allocate physical addr from RAM chunks
isRom32			equ		2					; type = 0010: use physical address of ROM
isRom24			equ		3					; type = 0011: use 24 bit mode physical address of ROM
isVidWrap		equ		4					; type = 0100: wrap to start of video buffer
isVideo			equ		5					; type = 0101: allocate physical addr from video buffer
isMap			equ		6					; type = 0110: use suggested physical addr from template
isVoid			equ		7					; type = 0111: map as invalid
isWrap24		equ		8					; type = 1000: start of 24-bit mode wrap	<7>
isVideoRAM		equ		9					; type = 1001: dedicated onboard video RAM	<9>
isEdisk			equ		10					; type = 1010: ram disk						<T11>

FullTblBit		equ		6					; bit number of full vs early termination field <H12>
FullTbl			equ		FullTblMask			; flag for enabling full MMU tables (no early term) <H12>

Template	RECORD	0,INCR				; Template Entry:
span		ds.l	1					;   span of the entry
physNflag	ds.l	1					;   suggested physical address, & flags		<7>
tEntrySize	equ		*					;   size of a template entry
			ENDR

;-----
;	The physical template tables describe the significant sections of the pysical address space.
;	These templates are used ONLY to generate the 'physical table', which is passed to VM and 
;	other foreign operating systems such as Pink/Opus and A/UX.  The 'physical table' is not used
;	for the vanilla Mac OS.
;
;	Each physical template entry describes a chunk of the physical address space.  Most of the
;	template entries are just copied to the actual physical table.  However, RAM intries are
;	dynamically generated.
;---

  					IF  	(&TYPE('kUsageRAM') = 'UNDEFINED') THEN

; values for PhysicalSpaceUsage

kUsageRAM				EQU		1
kUsageROM				EQU		2
kUsageIO				EQU		3
kUsageMinorSlot			EQU		4
kUsageMajorSlot			EQU		5
kUsageLowMemory			equ		6
kUsageBootGlobals		equ		7
kUsageOnboardVideo		equ		8
kUsageOnboardVideoWrap	equ		9
kUsageEDisk				equ		10

kUsageEndTable		equ		$FFFF
kUsageOther			EQU		0

; values for PhysicalSpaceAtributes bits

kCacheableBit		EQU		0				; MMU cacheable
kCacheableMask		EQU		1				; MMU cacheable

cacheable			EQU		kCacheableMask
notCacheable		EQU		0

; structure to describe a range of addresses

AddressRange		RECORD	0
address				DS.L	1				; start of range
rangeSize			DS.L	1				; size of range
size				EQU		*
					ENDR

; structure to describe a single block of PhysicalSpace

PhysicalSpaceBlock	RECORD	0
usage				DS.W	1				; what kind of block this is
attributes			DS.W	1				; MMU (and other) attributes
physical			DS.B	AddressRange	; physical address range
logical				DS.B	AddressRange	; suggested 32-bit address range
logical24			DS.B	AddressRange	; suggested 24-bit address range
	; more can be added here in later versions
size				EQU		*
					ENDR

; structure to describe an entire PhysicalSpace

PhysicalSpace		RECORD	0
numEntries			DS.W	1				; number of entries in table
entrySize			DS.W	1				; size of each entry in table
firstEntry			DS.B	PhysicalSpaceBlock	; first in variable-sized table
					ENDR

  					ENDIF
			
;-----
;	InitMMU 7a20 - sets up the MMU depending on what memory controller we are running and
;			  what chunks of RAM were found by StartTest.
;
;	Entry
;		'Universal ROM' registers
;  			a0 - Pointer to table of base addresses
;			a1 - Pointer to ProductInfo record for this machine
;			d0 - Flags indicating which base addresses are valid
;			d1 - Flags indicating which external features are valid
;			d2 - Bits 15..8, BoxFlag info (possibly unknown)
;			d2 - Bits  7..0, Address Decoder Kind (zero if unknown)
;			d7 - bits 31-16: logic board type
;			d7 - bits 15-0: cpu type (0 = 68000, 1 = 68010, 2 = 68020, 3 = 68030, 4 = 68040, etc.)	<2>
;
;		a6 - points to table of RAM chunks, tucked under the top of memory as follows:
;
;				------------  <--- top of highest RAM bank
;				+ <diags>  +   --- 2 longs at top of bank are trashed by diagnostics
;				+ <diags>  +   --- ditto
;				+ FFFFFFFF +
;				+  <size>  +
;				+  <addr>  +
;				+   ...    +
;				+  <size>  +
;				+  <addr>  +
;				------------  <--- a6
;
;				Ench RAM chunk is specified by its physical addess and size.  The table of
;				RAM chunks is terminiated by a single longword of $FFFFFFFF.  The code
;				depends on the table being sorted by chunk start address, with the lowest
;				addressed chunk pointed to by a6.
;
;
;	Exit
;		Universal registers d0-d2/d7,a0-a1 preserved
;		a4 - points to BootGlobs in logical space
;		sp - in the middle of the useable logical space
;
;	Trashes
;		d3-d5/a2-a7 (a4,sp as documented above)
;
;	Conventions Used:
;		Routines called by InitMMU assume they can trash d0-d1/a0, and must preserve
;		all other registers they use.  Exceptions to this rule should be cleary documented.
;---


Initframe		RECORD	{InitLink},DECR
InitRet			ds.l	1			; return address
InitLink		ds.l	1			; prev value link register
prodInfoPtr		ds.l	1			; saved a1 - Pointer to ProductInfo record for this machine
basesPtr		ds.l	1			; saved a0 - Pointer to table of base addresses
cpuType			ds.w	1			; saved d7 - bits 15-0: cpu type (0 = 68000, 1 = 68010, etc)
boxInfo			ds.w	1			;          - bits 31-16: logic board type
decoder			ds.b	1			; saved d2 - Bits  7..0, Address Decoder Kind (zero if unknown)
boxType			ds.b	1			;          - Bits 15..8, BoxFlag info (possibly unknown)
upperD2			ds.w	1			;          - upper word of d2
extFeatures		ds.l	1			; saved d1 - Flags indicating which external features are valid
basesValid		ds.l	1			; saved d0 - Flags indicating which base addresses are valid
SaveURegs		equ		BasesValid	; save universal registers here
globChunks		ds.l	sgMaxChunks*2;<SM6> CSS space for main RAM chunks (addr/size) (last addr -1)
eDiskChunks		ds.l	sgMaxChunks*2;<SM6> CSS space for eDisk chunks (addr/size) (last addr -1)				<T11>
lastPhysRam		ds.l	1			; offset in physical table to last RAM chunk entry
smallest		ds.l	1			; size of smallest chunk, in megabytes
VRAMPhysBase	ds.l	1			; base of video buffer, if any									<9>
VRAMrealSize	ds.l	1			; unrounded size of video buffer								<9>
VRAMSize		ds.l	1			; size of video buffer, rounded up to MMU page size multiple	<9>
logVRAMBase24	ds.l	1			; 24-bit logical base address of video							<9>
logVRAMBase32	ds.l	1			; 32-bit logical base address of video							<9>
logRomBase 		ds.l	1			; logical, 24 bit alias-able addr of ROM
physRomBase		ds.l	1			; physical ROM addr as the hardware sees it
soundBufferBase	ds.l	1			; base of sound buffer in high RAM (if any)						<H25><SM13>
soundBufferSize	ds.l	1			; size of sound buffer in high RAM (if any)						<H25><SM13>
InitSize		equ		*			; size of frame		
			ENDR

			WITH	InitFrame
			
UnivRegs	REG		d0-d2/d7/a0-a1			; registers to preserve for universality

InitMMU		link	a5,#InitSize			; set up stack frame
			bsr		SetupGlobals			; set up stack frame, boot globals
			bsr		FindInfo				; get ptr to MMU setup info
											; returns a0 = 32 bit info ptr, a1 = 24 bit ptr
			movem.l	SaveURegs(a5),UnivRegs	;   restore universal registers
		IF forRomulator	THEN				; 												<T11>
			TestInRAM	A2					; check if running ROM image in RAM				 |
			beq.s	@dontAdj				; IF in RAM										 v
			biglea	BaseOfROM,a4			;   get address base of ROM
			suba.l	a6,a4					;   calc offset from BootGlobs
			move.l	a4,sgAllocOff(a6)		;	save allocation offset	<SM6> CSS					 ^
@dontAdj									; ENDIF											 |
		ENDIF								;												<T11>
			move.l	a6,a4					;   return ptr to BootGlobs
			unlk	a5						;   remove stack frame
			rts								;   EXITROUTINE

;-----
;	SetupGlobals 7a38 - sets up the InitMMU stack frame and the BootGlobals record that is passed
;				   back to StartInit.
;
;	Entry:
;		
;  		a0 - Pointer to table of base addresses
;		a1 - Pointer to ProductInfo record for this machine
;		d0 - Flags indicating which base addresses are valid
;		d1 - Flags indicating which external features are valid
;		d2 - Bits 15..8, BoxFlag info (possibly unknown)
;		d2 - Bits  7..0, Address Decoder Kind (zero if unknown)
;		d7 - bits 31-16: logic board type
;		d7 - bits 15-0: cpu type (0 = 68000, 1 = 68010, etc)
;
;		a6 - points to RAM chunk table
;
;	Exit
;		InitMMU Stack frame set up
;		BootGlobals set up
;---

			WITH	DecoderInfo

SetupGlobals
			movem.l	UnivRegs,SaveURegs(a5)		; save universal regs
			move.l	ROMAddr(a0),d0				; get base address of ROM
			move.l	d0,logRomBase(a5)			; save it our globals

			tst.l	ROMPhysAddr(a0)				; Check if there is a defined physical ROM base	<H12>
			beq		@SavePhys					; IF defined physical ROM base THEN				<H12>
			move.l	ROMPhysAddr(a0),d0			;   use it instead of computed value			<H12>	

@SavePhys	move.l	d0,physRomBase(a5)			; save it in our globals
			moveq.l	#6,d0						; figure out what kind of MMU we have
			move.b	d0,sgTypeMMU(a6)			; save MMU type in BootGlobs					<SM6> CSS
			clr.l	VRAMSize(a5)				; assume no onboard video				<9>
			clr.l	VRAMrealSize(a5)			; assume no onboard video				<9>
			clr.l	VRAMPhysBase(a5)			; assume no VRAM						<9>

			MOVE.B	decoder(A5),D2				; get the decoder type							<H27><SM13>
			LEA		@Resume,A2					; (BSR2)										<H27><SM13>
			BRA.L	SizeSoundBuffer				; get sound buffer attributes (if any)			<H27><SM13>
@Resume		MOVE.L	A0,soundBufferBase(A5)		; save the base									<H27><SM13>
			MOVE.L	D0,soundBufferSize(A5)		;  and size of the sound buffer (if any)		<H27><SM13>

			move.l	#bRamDisk,sgRamDiskBase(a6)	; init logical base of eDisk					<T11><SM6> CSS
			clr.l	sgRamDiskSize(a6)			; assume empty ram disk							<T11><SM6> CSS
			clr.b	sgEDiskStealFlag(a6)		; assume no chunks to steal						<SAM>
			move.l	#-1,eDiskChunks(a5)			; make eDisk chunk table empty too

			lea		$FFFFFFA4,a0
			move.l	a0,sgAllocOff(a6)			; save allocation offset						<SM6> CSS

			clr.l	d3							;	clear counter								<T23>
			move.l	sgTestSpace+24(a6),d1		; Get the amount of bytes allocated by SizeMem for the EDisk	<MC3>
								;
			move.l	d1,sgRamDiskSize(a6)		;	save size of eDisk in boot globals			<T11> <SM6> CSS
@noEdisk										; ENDIF											<T11>

			lea		sgRamTable(a6),a0			; source = chunk table in BootGlobs				<SM6> CSS
			lea		globChunks(a5),a1			; destination = our globals
			bsr		CopyChunks					; copy RAM chunks to our globals
			move.l	d0,smallest(a5)				; remember smallest chunk size
			move.l	d1,sgTotalRAM(a6)			; remember total RAM size in BootGlobs			<SM6> CSS
												; a0 = top highest bank, d1 = total RAM
			sub.l	a0,d1						; normal phys-to-log offset = total - top

			moveq.l	#0,d0

;	IF NOT Supports24Bit THEN					;												<SM10> rb <SM11> rb
	
			bset	#mmFigEnable,d0				; Force 32-bit mode until we make room for a 2 meg rom <SM3> kc ••••
			bset	#MMStartMode,d0				; Force 32-bit mode until we make room for a 2 meg rom <SM3> kc ••••
			bset	#MMMixed,d0					; Force 32-bit mode until we make room for a 2 meg rom <SM3> kc ••••
			bset	#MMSysheap,d0				; Force 32-bit mode until we make room for a 2 meg rom <SM3> kc ••••
			bset	#MMROZheap,d0				; Force 32-bit mode until we make room for a 2 meg rom <SM3> kc ••••
			
;	ENDIF										;												<SM10> rb
	
			move.b	d0,sgMMFlags(a6)			; save memory mgr flags in BootGlobs <SM6> CSS
			move.l	d1,sgPhys2Log(a6)			; save physical-to-logical offset <SM6> CSS
			rts
			
			ENDWITH								; {DecoderInfo}

;_____________________________________________________________________________________________
;	Routine ReadPRAMByte 7ada
;
;	Inputs:		D0	-	byte # to read from PRAM
;				A5	-	local frame pointer for InitMMU
;
;	Outputs:	D0	-	byte read
;
;	Destroys:	??
;_____________________________________________________________________________________________
ReadPRAMByte
			movem.l	d1-d6/a0-a3,-(sp)		; save regs that may be trashed
			movea.l	basesPtr(a5),a0			; get ptr to hardware bases					<4.0>
			movea.l	prodInfoPtr(a5),a1		; get ptr to product info
			move.l	extFeatures(a5),d1		; get external features						<5>
			moveq	#1,d3					; read 1 byte
			swap	d3						; high byte contains count
			move.w	d0,d3					; low word contains byte # to read
			subq	#2,sp					; allocate buffer space
			movea.l	sp,a3
			bsr.l	PramIO					; read it and weep...						<5><H2>
			moveq	#0,d0
			move.b	(sp)+,d0				; get byte out of buffer
			movem.l	(sp)+,d1-d6/a0-a3		; restore regs
			rts

;_____________________________________________________________________________________________
;	CleanupGlobals 7b04
;
;	Fixes up the RAM entries in the physical space table to account for total space
;	occupied by boot globals and mmu tables.  Restores the 'universal' registers that were 
;	passed in to InitMMU.  Converts the ptr to BootGlobals into a logical address.  Stuffs 
;	a few last tidbits of useful information into BootGlobs.  Figures out logical return 
;	address for InitMMU.
;
;	Entry
;		a5 - points to InitMMU stack frame
;		a6 - physical address of BootGlobs
;
;	Exit:
;		universal registers d0-d2/d7/a0-a1 restored
;		d3 - ROM physical-2-logical conversion constant
;		a2 - InitMMU's logical return address
;		a3 - points to tc value in the 32 bit mode MMUConfigInfo record in BootGlobs
;		a4 - logical address of BootGlobals
;		sp - halfway through logical useable RAM space, clipped at 8 mb unless 'black hole'
;---

CleanupGlobals
			move.l	a6,a0						; get ptr to BootGlobs
			add.l	sgPhysicalTableOff(a6),a0	; get ptr to start of physical table <SM6> CSS
			add.l	lastPhysRam(a5),a0			; get ptr to entry for last RAM chunk
			move.l	sgTopOff(a6),d0				; get offset to top of boot globals area <SM6> CSS
			sub.l	sgAllocOff(a6),d0			; total size = top offset - bottom offset <SM6> CSS
			
			WITH	PhysicalSpaceBlock
			move.l	soundBufferSize(a5),d1		; get total RAM taken up by sound buffer		<H25><SM13>
			add.l	d0,d1						;  and boot globals								<H25><SM13>
			sub.l	d1,physical.rangeSize(a0) 	; adjust size last useable chunk				<H25><SM13>
			move.l	physical.address(a0),d1		; get address last useable chunk
			add.l	physical.rangeSize(a0),d1	; address bootglobs chunk = addr last + size
			adda.w	#PhysicalSpaceBlock.size,a0	; point at entry for boot globals
			move.l	d1,physical.address(a0)		; set address boot globals chunk
			move.l	d0,physical.rangeSize(a0)	; set size boot globals chunk
			move.w	#kUsageBootGlobals,usage(a0); set usage field of boot globals chunk
			ENDWITH

			move.l	(sp),d5						; remember return address
			move.l	a6,d0						; get physical ptr to BootGlobs
			add.l	sgPhys2Log(a6),d0			; convert to logical ptr <SM6> CSS
			move.l	d0,a4						; save logical ptr

		IF forRomulator	THEN					; 												<T11>
			TestInRAM	A2						; check if running ROM image in RAM				 |
			beq.s	@dontAdj					; IF in RAM										 v
			biglea	BaseOfROM,a0				;   get address base of ROM
			suba.l	d0,a0						;   calc offset from BootGlobs
			move.l	a0,sgAllocOff(a6)			;	save allocation offset	  <SM6> CSS					 ^
@dontAdj										; ENDIF											 |
		ENDIF									;												<T11>

			add.l	sgAllocOff(a6),d0			; get logical address top useable memory <SM6> CSS
			cmp.l	#$200000,d0					;	do we have at least two meg of RAM?			<5>
			bge.s	@plentyORam					;	IF we have less than two meg THEN			<5>
			lsr.l	#2,d0						;     divide amt useable logical memory by 4	<5>
			mulu.l	#3,d0						;	  multiply by 3 to get 3/4 of useable memory<5>
			bra.s	@stakOk						;	  go set stack								<5>
@plentyORam										;	ELSE										<5>
			move.l	#defStackAddr,d0			;	  use default stack size 					<5>
@stakOk											;   ENDIF
			move.l	d0,sp						;   set new stack

			biglea	BaseOfROM,a1 				; get physical base address of ROM
			move.l	logRomBase(a5),d3			; get future logical base addr ROM
			sub.l	a1,d3						; get ROM phys-2-log conversion constant
			
			move.l	InitRet(a5),a2				; get InitMMU's return address
			add.l	d3,a2						; convert return addr to logical addr
			lea		sg32Info+theTC(a6),a3		; point at 32 bit mode tc  <SM6> CSS
			movem.l	SaveURegs(a5),UnivRegs		; restore 'universal' registers
			movea.l	d5,a5						; get return address
			jmp		(a5)						; return to caller
			
;-----
;	SaveMMUInfo 7b86 - save tc, tt0, tt1, create and save crp
;
;   Entry:	d0 has 1st longword of crp
;			a0 points to translation table
;			a1 points to MMUConfigInfo record where info should be saved
;			a2 points to layout info
;-----

SaveMMUInfo	move.l	newtc(a2),theTC(a1)			; move tc
			move.l	newtt0(a2),theTT0(a1)		; move tt0
			move.l	newtt1(a2),theTT1(a1)		; move tt1
			move.l	d0,theCRP(a1)				; save 1st half of crp
			move.l	a0,theCRP+4(a1)				; save 2nd half crp on 030, full srp on 040
			cmp.w	#cpu68040,d7				; running on a 68040?						<7>
			bne.s	@exit						; IF on 68040								<7>
			andi.l	#$fffffe00,theSRP(a1)		;   bits 0-8 of SRP must be zero			<7>
@exit											; ENDIF										<7>
			rts


;-----
;	MMUError 7bac - unrecoverable error discovered while setting up MMU.
;---
MMUError	move.w	#102,d6				; minor error code = MMU setup error			<3.2>
			move.l	#$0F,d7				; major error code = NuMac error				<3.2>
			bra.l	Critical
			

;-----
;	CopyChunks 7bb8 - copies a RAM chunk table, skipping zero sized chunks, remembering 
;				 the smallest one, and accumulating the total size of all the chunks.
;
;	Entry
;		a0 - points to source table of chunks
;		a1 - points to destination table of chunks
;
;	Exit
;		d0.l - size of smallest RAM chunk
;		d1.l - total size of all chunks
;		a0.l - ptr to end of last chunk
;---

CopyRegs	REG		d2-d5
CopyChunks	movem.l	CopyRegs,-(sp)		; save work regs
			moveq	#0,d1				; init total RAM size to zero
			moveq	#-1,d0				; init smallest size to huge
			moveq	#-1,d5				; end of table marker
			bra.s	@startloop			; start in the middle...
@copyLoop								; LOOP thru RAM chunks in BootGlobs
			cmp.l	d0,d3				;   check chunk size
			bhs.s	@smallOK			;   If it is the smallest so far
			move.l	d3,d0				;     save the new smallest size
@smallOK								;   ENDIF
			add.l	d3,d1				;   add bank size to total
			move.l	d2,d4				;	get ptr to start of bank
			add.l	d3,d4				;   ptr to end = start + size
@startloop	move.l	(a0)+,d2			;   get next addr from source
			move.l	(a0)+,d3			;   get next size from source
			move.l	d2,(a1)+			;   save addr in destination
			move.l	d3,(a1)+			;   move size to destination
			bne.s	@sizeOK				;   IF size is zero
			subq	#8,a1				;     back up 1 entry in destination
@sizeOK									;   ENDIF
			cmp.l	d5,d2				;   check for end of list marker
			bne.s	@copyLoop			; REPEAT till end of list
			move.l	d4,a0				; return ptr to end of bank
			movem.l	(sp)+,CopyRegs		; restore regs
			rts
			
			
;-----
;	FindInfo - massage RAM chunks based on what type of hardware we are on, and return 
;			   pointers to the layout tables to use in setting up the MMU.
;
;	On a machine with RBV onboard video, the video buffer space is removed from the Bank A 
;	chunk, and the chunks are rearranged so that Bank B, if present, appears first in the
;	table.  This makes logical low memory show up in Bank B's faster RAM once the MMU tables
;	are set up.
;
;	On machines with a simple split memory architecture, the size of the smallest chunk is  
;	used to pick which layout table to use.  This allows smaller tables with larger RAM sizes.
;
;	Entry:
;		a5 - points to InitMMU global stack frame
;		a6 - points to BootGlobs
;
;	Exit:
;		InitMMU stack frame updated with massaged list of RAM chunks.
;		a0 - points to 32 bit mode layout info
;		a1 - points to 24 bit mode layout info
;---
			WITH	DecoderInfo

FindRegs	REG		d2-d6/a2			;												<3.0>
FindInfo	movem.l	FindRegs,-(sp)		; save work registers
			movem.l	globChunks(a5),d2-d5; d2-d3, d4-d5 = first two RAM chunks addr/size
			move.l	basesPtr(a5),a1		; get ptr to table of base addresses
			move.l	basesValid(a5),d6	; get mask of valid base addresses
			moveq	#0,d0				; clear a reg
			move.b	decoder(a5),d0		; get controller type
			move.w	@casetbl(d0.w*2),d0	; get offset to controller routine
			jmp		@casetbl(d0.w)		; SWITCH(controller type)
@casetbl	dc.w	@bad-@casetbl		; .(unknown)
			dc.w	@bad-@casetbl		; .(Mac Pal)
			dc.w	@bad-@casetbl		; .(BBU)
			dc.w	@bad-@casetbl		; .(Normandy)
			dc.w	@bad-@casetbl		; .(Mac2Glue)
			dc.w	@bad-@casetbl		; .(MDU)
			dc.w	@bad-@casetbl		; .(OSS FMC)
			dc.w	@bad-@casetbl		; .(VISA has MMU similar to HMMU)				<12><T22>
			dc.w	@bad-@casetbl		; .(Orwell)										<7><T22>
			dc.w	@bad-@casetbl		; .(Jaws)										<9>
			dc.w	@bad-@casetbl		; .(MSC)										<T19>
			dc.w	@bad-@casetbl		; .(Sonora)										<H4>
			dc.w	@bad-@casetbl		; .(Niagra)										<H8>
			dc.w	@bad-@casetbl		; .(YMCA)										<SM7> fau <LW2>
			dc.w	@bad-@casetbl		; .(djMEMC)										<H20><SM13>
			dc.w	@exp-@casetbl		; .(HMC)										<SM8>
			dc.w	@bad-@casetbl		; .(Pratt)										<SM14>
			dc.w	@exp-@casetbl		; .(HHead)									
			dc.w	@exp-@casetbl		;
			dc.w	@exp-@casetbl		;
			dc.w	@exp-@casetbl		;
			dc.w	@bad-@casetbl		;
			dc.w	@exp-@casetbl		;
			dc.w	@exp-@casetbl		;
			dc.w	@exp-@casetbl		;
			dc.w	@exp-@casetbl		;
			dc.w	@exp-@casetbl		;
			dc.w	@bad-@casetbl		;

			Align	4
@bad									; CASE non-MMU based controller:
			bra		MMUError			;   we're hosed...
@exp									; CASE some new controller:
			movem.l	(sp)+,FindRegs		; restore work registers
			rts


			ENDWITH							; {MMUConfigInfo}
			ENDWITH							; {BootGlobs}


			ENDPROC
			END


