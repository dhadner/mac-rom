;__________________________________________________________________________________________________
;
;	File:		StartInit.a
;
;	Contains:	This code must be placed at the very beginning of the ROM. It contains the hardware
;				start vectors and low level hardware initialization code.  It is entered through the
;				reset vector on a hardware reset or cold start.
;
;	Originally written			by Larry Kenyon				February 1983
;	Substantially rewritten		by Wayne R. Loofbourrow		June 1986
;	Hopelessly scrambled		by Jerome T. Coonen			mid-September 1986
;	Mercilessly hacked			by everyone but the Pope	throughout 1989 and beyond
;	Unscrupulously kludged		by TERRORists				first year, last decade, 20th century
;	Totally messed up			by SuperMario players		Nov 1991-Jan 92
;	Released upon the world		by Pandorists (Not!)		MCMXCII
;	Scrambled again				by SuperMario World			May 92 - Dec 92
;	Repaired					by PDM guys					1993
;	Spell-Checked				by TNT guys					shortly thereafter
;
;	Copyright:	© 1983-1994 by Apple Computer, Inc.  All rights reserved.
;
;	Change History (most recent first):
;
;	 <SM163>	  2/2/94	DCB		Added call to INITSCSIBOOT so that it gets called after Slot
;									Interrupts and ADB are initialized.  It used to be called from
;									SCSIMgrInit but that was too early and screwed up third party
;									SIMs.
;	 <SM161>	 1/28/94	chp		For TNT: allow most everything except the .Sound driver.
;	 <SM160>	  1/4/94	LB		For TNT: allow floppy driver installation.
;	 <SM159>	12/13/93	PN		Roll in KAOs and Horror changes to support Malcom and AJ
;									machines.
;	 <SM158>	 12/2/93	chp		For TNT: allow serial driver installation.
;	 <SM157>	11/10/93	chp		For TNT: enable VIA interrupts for SetUpTimeK; install a
;									pseudo-slotVBL interrupt for PCI video cursor tracking; disable
;									several drivers.
;	 <SM156>	 11/9/93	KW		added some eieioSTP macros.  Only expands for CygnusX1 ROM
;	 <SM155>	 11/8/93	SAM		Roll in <MC7> from mc900ftjesus.
;	   <MC7>	 11/8/93	SAM		Removed some confusing, misleading, and commented out code to
;									adjust gestalt's lram size (following initgestalt).
;	 <SM154>	10/25/93	SAM		Roll in <MC6> from mc900ftjesus.
;	   <MC6>	10/25/93	SAM		Moved the call to CheckforResetPRAM a little earlier in the boot
;									(just following the Cuda/Egret init).
;	 <SM153>	10/15/93	SAM		Roll in <mc5> from mc900ftjesus.
;	   <MC5>	10/15/93	SAM		Deleted the NuBusReset code for Bart (leftover from the last
;									checkin).  Removed the code that created the bogus "heap"
;									gestalt selector.
;	 <SM152>	10/12/93	SAM		Roll in <MC4> from mc900ftjesus.
;	   <MC4>	10/12/93	SAM		Moved the Bart Nubus reset from here to USTStartup.  Made the
;									figment "heap" gestalt setup universal.
;	 <SM151>	 10/4/93	JDR		undo change SM150. it was already being done in SndPrimitives.a
;	 <SM150>	 10/1/93	KW		Installing tables for sound primitives. Allows Quadras/Wombats
;									to record, set volume level etc. Great if moved to SoundMgr
;									initialization code.
;	 <SM149>	 9/28/93	SAM		From mc900ftjesus.
;	   <MC3>	 9/26/93	pdw		Added NOT hasAsyncSCSI around call to InitSCSIHW since
;									InitSCSIMgr does the hardware init when AsyncSCSI is present.
;	   <MC2>	 9/25/93	SAM		Removed the build time conditional around the call to InitEgret.
;									Added a runtime check to EgretDFACandPDM.  Cleaned up the
;									intialization of SoundBase (again). Changed CheckForEgret to
;									CheckForEgretOrCuda. Removed PDM Evt1 support from NuBusReset &
;									DynamicBoxFlag
;	 <SM146>	 9/13/93	SAM		Updated the Gestalt heap install stuff.  Initialized the
;									HeapUtilities globals ptr .
;	 <SM145>	 9/12/93	pdw		Split up InitIOMgr into InitIOPStuff, InitDeviceMgr and
;									InitDrivers.
;	 <SM144>	  9/3/93	GMR		Changed bit used for BART slot disable from bit 0 to bit 7. Also
;									fixed a problem found by Fernando in RdVidParam that causes us
;									not to boot if we have a video card without on-board video
;									connected.
;	 <SM143>	 9/1/93		SKH		Finish SetupTimeK export.  (Forgot to add change history)
;	 <SM142>	 9/1/93		SKH		Export SetupTimeK because the portable dynamic speed stuff needs it
;	 <SM141>	 8/23/93	pdw		Added support for LimitPRAMClear, IgnoreCmdOptShDel,
;									LoadDefaultOnly - three options required for AIX security,
;									enabled by setting bits in PRAM $76.
;	 <SM140>	 8/20/93	BG		Modified DynamicBoxFlag to know about CarlSagans.
;	 <SM139>	 8/20/93	chp		Rather than calling InitPDMDMA explicitly from StartInit,
;									install that routine as an interrupt initialization postproc in
;									the AMIC interrupt primitives table. (See InterruptHandlers.a).
;									It is executed as part of the call to InitIntHandler.
;	 <SM138>	 8/16/93	RC		Made changes to CheckForResetPRAM routine.  I added support for
;									saving off some of the PRAM information which is needed for
;									security reasons (mostly needed by the AUX team)
;	 <SM137>	 8/12/93	SAM		Undid the last two changes (not needed).  Added code to
;									NuBusReset to disable Slot E IRQs for multiple slot PDM style
;									machines with a BART NuBus controller.
;	 <SM136>	 8/12/93	KW		adding two more smurf wombats
;	 <SM135>	 8/11/93	KW		added some branches based on new smurf boxes
;	 <SM134>	  8/4/93	JDR		Integrate sound manager 3.0 project.
;	 <SM133>	  8/3/93	GMR		Added code to issue a NuBus reset on PDM machines with BART.
;									Ideally, this should be before diagnostics....
;	 <SM132>	 7/20/93	SAM		Changed the name of the offset in the new ROM header that points
;									to the 7.0 toolbox init code to be "InitSys7ToolBoxOff" instead
;									of InstallMgr which wasn't very descriptive.  Added code to
;									create 768 master pointers in the System heap at its creation.
;									This will help keep the sys heap from becoming fragmented.
;	 <SM131>	  7/9/93	PN		Remove my last change
;	 <SM130>	  7/2/93	PN		Add conditional hasCPUIDregister
;	 <SM129>	  7/1/93	KW		Set SoundBase to ROM address 40800000 if ROM is in RAM.
;	 <SM128>	 6/29/93	SAM		Added code to install a "heap" gestalt selector if Figment is
;									around.
;	 <SM127>	 6/29/93	SAM		Commented out the code that added the Edisk size to the
;									*physical* RAM size!  All logical RAM size adjustments are made
;									from within Gestalt (as it was).
;	 <SM126>	 6/24/93	SAM		Updated PDM's dynamic boxflag code to include a new set of
;									"boxes" (fridge).
;	 <SM125>	 6/22/93	kc		Setuo parameter to FROVideo before calling it.
;	 <SM124>	 6/21/93	kc		Fix InitIOMgr so that it doesn't trash a0 (and the UnitTable).
;	 <SM123>	 6/17/93	rab		Moved initialization of expandmem to before InitIntHandler.
;									Fixes some boot problems caused by the Ludwig roll-back.
;	 <SM122>	 6/14/93	kc		Roll in Ludwig.
;	  <LW17>	 4/14/93	fau		Made the CheckForTV use CivicExists, instead of BoxFlags.
;	  <LW15>	 4/11/93	chp		Rewrite serial driver installation code in InitIOMgr. Use
;									ProductInfo to select the correct 'SERD' resource.
;	  <LW14>	  4/9/93	fau		Changed the EdiskDriver to use the InstallDrvr routine so that
;									it doesn't stomp on a previously installed driver.
;	  <LW13>	  4/8/93	fau		Changed the open of the netboot driver to use the InstallDrvr
;									routine, so it uses the lowest refnum above -47, instead of the
;									resource id.  This is much more friendly.
;	   <LW7>	 2/16/93	ejb		move initialization of realtime mgr, rt drvr, and dsp std snd to
;									gibbly so that strings and icons can be localized.
;	   <LW6>	 2/11/93	PW		Removing IMPORT of SCSILoad (it's not used in this file).
;	 <SM121>	  6/3/93	SAM		Chas.  I thought we had an agreement here...  Added dynamic
;									boxflag hack for HMC machines.
;	 <SM120>	  6/1/93	CSS		Touch this file so Universal ROM version can be updated (v $02).
;	 <SM119>	 5/18/93	CSS		Touch this file so Universal ROM version can be updated (v $01).
;	 <SM118>	  5/9/93	SAM		Removed bogus soundmgr init code that was writing an
;									uninitialized value into the sound mgr globals.
;	 <SM117>	  5/7/93	joe		& CCH.  Bumped MinSysExtra constant to compensate for all the
;									new stuff being thrown in.  It's previous size was causing
;									booting problems on PDMs and Smurfs.
;	 <SM116>	  5/6/93	SAM		Removed some _SwapMMUMode calls.  Fixed ConfigureRAM to not
;									write past the top of RAM if the RAM size is not a multiple of
;									64k.  Changed another one of those nasty SIGNED address
;									comparisons.
;	 <SM115>	  5/5/93	CSS		Touch this file so Universal ROM version can be updated (v $00).
;	 <SM114>	 4/20/93	CSS		Touch this file so Universal ROM version can be updated.
;	 <SM113>	 4/11/93	chp		Rewrite serial driver installation code in InitIOMgr. Use
;									ProductInfo to select the correct 'SERD' resource.
;	 <SM112>	  4/8/93	SAM		Added calls to "INSTALLBASSCOMMON" and "FORCEINITFONTSCALL" to
;									initalize Bass before the first call to _InitGraf (which calles
;									_InitFonts).
;	 <SM111>	  4/1/93	GMR		Moved PDM's DMA stuff to InterruptHandlers.a.
;	 <SM110>	 3/31/93	GMR		Fixed a bug in PDM's DMA handler when dealing with bits 8,9.
;									Optimized the handler. This stuff belongs in InterruptHandlers.a, 
;									and will be moved there soon.
;	 <SM109>	 3/31/93	chp		Remove support for Cyclone EVT3 (limited changes from Ludwig).
;	 <SM108>	 3/25/93	RB		In order for interrupt handlers to run from RAM when running a
;									virtual ROM, the InfoRecord needs to be adjusted so it points to
;									its RAM copy.
;	 <SM107>	 3/11/93	SAM		Indirection, indirection.  Why use one instruction when you can
;									use two.  Lvl5IrqHandler.
;	 <SM106>	 3/11/93	SAM		Added a check before the adjustment to total ram size before
;									InitGestalt that wont adjust anything if the EDisk was not
;									stolen from the 68k mmu tables.  Added a refCon to the DMA irq
;									handler.
;	 <SM105>	  3/4/93	RC		Added check of AMIC to determine if we need to load the SERD 1
;									resource or not.  One line is currently commented out to keep it
;									from loading until we have fixed hardware
;	 <SM104>	 2/25/93	RB		When running from RAM, the hard coded offsets used for ROM
;									vectors need to be adjusted after calling InitROMVectors.
;	 <SM103>	 2/23/93	RC		Bug fix to the Level 5 Interrupt Handler for PDM/AMIC
;	 <SM102>	 2/22/93	RC		Use a Gestalt check around GoNative.
;	 <SM101>	 2/20/93	SAM		Ok, here goes...Added a InitDMA routine that sets up a structure
;									in expandmem for dealing with multiple DMA interrupt sources.
;									Rearranged several calls after BootRetry to 1) make more sense,
;									and 2) necessitate creating expandmem much earlier than it
;									previously was.  Moved the installation of the 040BlockMove
;									routine much earlier.  Put several Supports24Bit's round things.
;									Changed many *signed* comparisons - everyone needs to stop
;									making singed Address comparisions!  Made the GoNative install
;									universal.
;	 <SM100>	 2/12/93	PN		Change BEQ.S to BEQ.W to fix the build
;	  <SM99>	 2/10/93	RB		Reviewed by CS. Added code to copy ROM code into RAM for
;									performance. Removed some of the NOT LC930 stuff, since it is
;									obsolete after the test code Steve added.
;	  <SM98>	  2/5/93	GMR		Added check for SWIM3 in InitIOMgr, to support SonyDriver on
;									PDM. Extended SetupHWBases to deal with all 96 basesValid bits.
;									Setup IWM in SetupHWBases if SWIM3Exists.
;	  <SM97>	  2/5/93	RC		GoNative is needer for both PDM and Smurf
;	  <SM96>	  2/5/93	SAM		Temporarily conditionalize assembly of the GoNative installation.
;	  <SM95>	 1/15/93	RC		Took out the Auto Launch of RAM Disk on PDM
;	  <SM94>	 1/10/93	RC		Added more nops for Smurf
;	  <SM93>	12/23/92	RC		GoNative turned back on
;	  <SM92>	12/21/92	SWC		Pulled InstallPrivTrap out of the has040MMU conditional since it
;									installs the correct routine into the trap for both an Ô881 and
;									an Ô040 style FPU.
;	  <SM91>	12/17/92	RB		Removed some of the LC930 conditionals now that Steve added a
;									bunch hasPwrControls conditionals. Changed some of the other
;									LC930 conditionals to use has2MegROMOrMore. Others were changed
;									to has040. Re-enabled some 24 bit mode code with the conditional
;									Supports24Bit.
;	  <SM90>	12/11/92	RC		Temporarily comment out the Branch to GoNative until the
;									GoNative code is a little more ready for the ROM
;	  <SM89>	12/11/92	SWC		Rearranged stuff at BootRetry so that machine/feature specific
;									support can be setup earlier so there's not a gray region where
;									the world is kinda set up.
;	  <SM88>	12/10/92	JDB		ejb: Fix my ENDIF
;	  <SM87>	12/10/92	ejb		remove code for installing RTSndIn Driver- as this is not
;									needed.  The SoundMgr will take care of this.
;	  <SM86>	 12/8/92	RC		Installing GoNative as soon as Resource manager and memory
;									manager are up and alive
;	  <SM85>	 12/8/92	SWC		Fixed an LC930 gotcha from <SM84>.
;	  <SM84>	 12/8/92	SWC		Moved LCDScreenChk->PowerMgr.a. Cleaned up the backlight, DSP
;									driver loading since some pieces of code were duplicated 3
;									times. Did some general cleanup and removed unused code.
;     <SM83>	12/06/92	HY		Remove space in .Sound and .EDisk definitions as a result of 
;									change in <SM82> which preceded strings with STRING PASCAL directive.
;									This caused the EDisk and Sound drivers from being loaded.
;	  <SM82>	 12/5/92	SWC		Moved InitSndHW, InitSndNoRAM to SndPrimitives.a. Removed the
;									ASC test before the call to InitSndHW since that routine will
;									now do what's appropriate for each machine. Cleaned up the
;									initial low mem setup. Removed the PowerBook 140 boxFlag patch.
;	  <SM81>	 12/4/92	SWC		Moved InitMemMgr->MemoryMgr.a, InitRsrcMgr->ResourceMgr.a,
;									InitDTQueue->DeferredTaskMgr.a, SwitchMMU->MMU.a.
;	  <SM80>	 12/3/92	PN		Back out the change in SM72 since a better fix is implemented in
;									Startboot.a
;	  <SM79>	12/02/92	HY		Zeroed out memory on stack before calling InitEgretAlt. This could 
;									potentially cause sporadic crashes on RESTART. Also changed 
;									InitHiMemGlobals to use BaseOfROM to decide where BufPtr should
;									be set to in 24-bit mode (LC based machines are at $00A00000).
;									Bracketed call to EnableSwimIOPInts in InitIOMgr with "IF hasIopSwim".
;	  <SM78>	 12/2/92	SWC		Moved PortableCheck to PowerManager.a.
;	  <SM77>	 12/2/92	ejb		move installation of RTSnd beforeRTDrvr since driver now calls
;									StdSndSignInCPUDevice
;	  <SM76>	 12/1/92	SWC		Removed the call to EnableParityInts since it was only used on
;									the IIfx (and has gone away).
;	  <SM75>	11/25/92	PW		Changed minSysExtra value from 16K to 64K to attempt to (and
;									apparently did) fix the many drivers-not-loading bugs (NewPtr
;									failed).
;	  <SM74>	11/24/92	RB		In the SetApp_Base routine, put support for 24 bit mode.
;	  <SM73>	11/20/92	fau		Put a test around InitSndHw so we don't call it if an ASC doesn
;									not exist.  Enabled MUNI Interrupts on Cyclone.
;	  <SM72>	11/19/92	PN		Radar #1050264 the SetAppBase patch needs to be rolled in
;									correctly. At the early init time, the patch to the _SetAppBase
;									is not needed. Yet we roll the patch into SetApplBase routine so
;									we have to replace _SetAppBase with JSR SetApp_Base so that the
;									_InitApplZone is not called.
;	  <SM71>	11/14/92	kc		Export MyROM.
;	  <SM70>	11/11/92	RB		The code that sets MemTop should be executed before Gestalt is
;									initialized. Moved the code to earlier in the boot process. Put
;									back the old Sound Manager (7.1) for the LC930, since Sadism is
;									not ready.
;	  <SM69>	11/11/92	GD		Made a change to support Romulator for PowerBooks.
;	  <SM68>	 11/7/92	rab		Roll in Horror changes. Comments follow: ¥ÊFrom StartInit.a ¥
;		<H11>	 8/25/92	BG		Modified SetupTimeK so that the VIATime loop is unaligned. This
;									'fixes' a problem with the floppy driver doing a wait loop that
;									is unaligned and taking too long, causing MFM writes to occur
;									too late.
;		<H10>	 7/21/92	NJV		Removed hasSonora1 conditionalized code (no longer needed)
;		<H9>	 7/13/92	GMR		Now initialize ExpandMem before InitADB so we can initialize the
;									CrsrDev stuff when InitADB is called.
;									¥ÊFrom StartInitPatch.a ¥
;		<H19>	 9/13/92	NJV		Added initialization of DJMEMC's new diagnostic register on a
;									warm start (the Sound Block Configuration Register).
;		<H16>	07-01-92	jmp		Made the change in <H13> only take effect on warm-starts.
;		<H13>	06-26-92	jmp		Added some code to InitSoundHW that checks for the presence of a
;									djMEMC.  If a djMEMC exists, this code then shuts off the
;									djMEMC's (DAFB's) sync control so that video is off BEFORE the
;									boot beep occurs.
;		<H12>	 6/24/92	ag		Added Dartanian to the list of cpu's which must use the sound
;									pan registers for volume control. Allow Zero volume which will
;									mute the boot beep. Zero volume is only achived if the user set
;									it to zero, invalid pram will default to level 5.
;	  <SM67>	11-04-92	jmp		Cleaned up the enable cache code to be a little more
;									maintainable.
;	  <SM66>	 11/4/92	mal		Put back enable cache code that was erroneously removed in rev
;									64.   Removed 2nd StartInit.a from end of file that was
;									erroneously added in rev 64.
;	  <SM65>	 11/3/92	RB		Changed the use of LC930 in the 24 bit mode support test to
;									Supports24Bit. Change the include of SCSIEqu.a to SCSI.a,
;									VideoEqu.a to Video.a and ATalkEqu.a to AppleTalk.a
;	  <SM64>	 11/3/92	fau		Together with Mlaw:  Loaded a new SoundBase that points to the
;									start of the MarioBootSound in ROM, instead of the middle of
;									ROM.  Also, chaned the gestalt in <SM59> to use a TestFor macro,
;									as it is much faster.
;	  <SM63>	 11/2/92	fau		Added a check on Cyclone/Tempest to determine if the user has
;									Cmd-opt-T-V held down (if so, it will allow for booting off
;									without a monitor, directing output to the composite video
;									port).
;	  <SM62>	10/30/92	RB		On the LC930, do not force 32 bit mode, since it supports 24 bit
;									mode.
;	  <SM61>	10/29/92	RB		Removed the temporary ADBReinit call I added because it takes a
;									long time. Added a low ROM address for InitROMVectors since the
;									intl' OS guys need it.
;	  <SM60>	10/27/92	CSS		Changed some short branches to word branches.
;	  <SM59>	10/27/92	fau		Used gestaltSoundHardware to determine whether to install the
;									sound interrupt handlers for ASC machines.
;	  <SM58>	10/22/92	fau		Moved ADBReinit <SM56> to before grayscreen, so that the user
;									won't see a frozen mouse.  This call should just be temporary
;									and a fix to the Q950 should be found.  ADBReinit takes like 1
;									second to execute!
;	  <SM57>	10/22/92	fau		Got rid of all MMCExists by making them DSPExists or PSCExists.
;	  <SM56>	10/22/92	RB		Exclude any PowerManager calls from the LC930 build (1 Meg ROM).
;									Call ADBReInit at Startup to fix the mouse freeze bug in 950's.
;									Made the startup port be the one that Boot3 expects as defined
;									in the BootGlobals.
;	  <SM55>	10/18/92	CCH		Added a nop to flush pending writes and a RAM Disk on PDM.
;	  <SM54>	10/12/92	RB		Exclude 040 specific code from the LC930 1 Meg ROM build.
;	  <SM53>	 10/7/92	CSS		Fixed so only non-cyclone machines will load the SoundDriver which
;									is now back in ROM.  This is a hack to get the sound volume on Quadra to
;									work.
;	  <SM52>	 10/6/92	RB		Added the ROMinRAM conditional to avoid RESET when buidling a
;									ROM that will be copied to RAM in order to do testing. Killed
;									the register to use with some of the BIG macros, since the
;									macros have been updated for 68020's.
;	  <SM51>	 10/5/92	PN		Fix MacII si booting process with InitROMVector after InitMMU
;	  <SM50>	 10/2/92	PN		Set 32bit mode in PRAM
;	  <SM49>	 9/18/92	kc		Change InitVectors to InitRomVectors. Change short branches to
;									long branches.
;	  <SM48>	  9/8/92	chp		Install default primary SCC interrupt handlers as soon as the
;									PSC dispatch table is set up on Cyclone, and enable SCC
;									interrupts once and for all. InitSCC rewritten to remove
;									unnecessary code left over from pre-ADB Macs.
;	  <SM47>	 8/26/92	kc		Roll in Horror changes.
;		<H9>	 7/13/92	GMR		Now initialize ExpandMem before InitADB so we can initialize the
;									CrsrDev stuff when InitADB is called.
;		<H5>	 2/12/92	SWC		Added a call to InitCrsrDev in InitCrsrMgr so that the new mouse
;									acceleration stuff can be installed. Moved call to InitCrsrMgr
;									to just after ExpandMem is initialized since the CrsrDev stuff
;									keeps its globals there.
;	  <SM46>	 8/26/92	PN		Set SoundBase global to a safe location since it is no longer
;									valid.  Apps that write to this address will safely write to
;									ROM.
;	  <SM45>	 8/19/92	CSS		Update from Reality:
;									<72> 8/18/92 DTY	Change the name of BootGlobs to StartGlobals to avoid confusion
;														with BootGlobals, which is used by the boot code in Boot[1-3].a.
;	  <SM44>	 8/17/92	CCH		Extended universal support to 96-bits.
;	  <SM43>	08-11-92	jmp		Added ReAnimator support for '030 CPUs (taken straight from
;									HORROR).
;	  <SM42>	  8/9/92	CCH		Added conditional StartPC address for Smurf cards.
;	  <SM41>	 7/28/92	WS		Init DSP now use gestaltRealtimeMgr instead of checking the box
;									flags
;	  <SM40>	 7/27/92	RB		The ExpandMem record should be allocated just after we have a
;									System heap. When the resource Manager is called some of its
;									routines use the ExpandedMem record, which was being allocated
;									way after many things called the Resource Manager. Main bug
;									fixed was trashing SCCRd for the serial drivers.
;	  <SM39>	 7/24/92	RLM		move initGestalt before InitIOMgr, this allows lockmem calls
;									from initNewAge, note GetEDiskSize in initGestalt no longer
;									requires the drivers to be installed, also InitSCSIMgr comes
;									after InitIOMgr per Pauls request
;	  <SM38>	 7/15/92	JDB		Removed the code to install the SoundInput driver (it was
;									commented out and unnecessary).
;	  <SM37>	  7/9/92	RB		The Sound Manager was not working right on the Quadras because
;									the routine to enable the interrupts from the old Sound Manager
;									needed to be called and it wasnt.
;	  <SM36>	  7/7/92	RB		Added back a call to INITIALIZESOUNDMGRCOMMON from the sound
;									manager for sound input.
;	  <SM35>	  7/6/92	RB		Put back InitSndDispatch and InitMACEDispatch because Jim says
;									we need them after InitSoundMgr.
;	  <SM34>	 6/29/92	RB		Removed the old calls to initialize the sound manager and
;									replaced it with a new call, InitSoundMgr for the new new sound
;									manager.
;	  <SM33>	 6/25/92	kc		Do what I said I did last time.
;	  <SM32>	 6/25/92	kc		Disable the data cache on Cyclone until after InitSlots. This is
;									to work around a bug in MMC that will be fixed in EVT4. The
;									problem is caused when MUNI asserts TEA and another buss master
;									starts a transation befor MMC times out. The new MMC will watch
;									for TEA as well as TA for cycle termination.
;	  <SM31>	 6/25/92	PN		Put in init routine for WindowMgr to allocalte an extend memory
;									varialble
;	  <SM30>	 6/25/92	ejb		Add code to initialize RTSnd (DSP Standard Sound). Added and
;									disabled code to install RTSndIn (DSP Sound Input Driver).
;	  <SM29>	 6/24/92	chp		Use different SERD resource with PSC to enable DMA Serial
;									Driver.
;	  <SM28>	 6/22/92	kc		Added call to INITVECTORS.
;	  <SM27>	 6/22/92	ejb		Re-enabled DSPManager for EVT2 Cyclones.  Added branch to
;									DSPDriver initialization just before Sound Manager stuff.
;	  <SM26>	 6/20/92	ejb		Completely disabled RTMgr initialization for all EVTx units
;									until RTMgr rev'd to BOMII d12.
;	  <SM25>	 6/18/92	RB		Added a compile time conditional to ¥ temporarily not open the
;									DSP (RealTime Manager) on Cyclones other than EVT1 Cyclone.
;	  <SM24>	 6/15/92	RB		Caches should be disabled on Cyclone only during development.
;	  <SM23>	 6/12/92	PN		Roll in patchIIciROM.a. Check for PowerBook140 and set the
;									boxflag
;	  <SM22>	 6/10/92	JSM		PatchMDJGNEFILTER is now MDJGNEFILTER.
;	  <SM21>	  6/1/92	RB		¥ Temporary: Do not open the NewAge driver on Cyclone since it
;									frezzes the machine.
;	  <SM20>	 5/28/92	kc		Hack DrawBeepScreen.
;ÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊÊ¥¥¥ÊWe need to Roll in the WindowMgrPatch file from Horror ¥¥¥
;	  <SM19>	 5/28/92	CS		Call to Open the video driver needs to be added.
;	  <SM18>	 5/28/92	kc		¥¥¥ Kill the caches for ROM bring up. ¥¥¥
;	  <SM17>	 5/27/92	CS		Fix problem with label @noMMC jumping backwards. Need to change
;									name as it exists in this scope.
;	  <SM16>	 5/24/92	RB		Making Cyclone changes...Updated some of the old comments which
;									seemed to have been cut-off by some tool. Call EgretDFACandPDM
;									from the Pandora roll-in instead of QuadraEgretChanges. Added
;									code that installs the DSP Manager at runtime after checking for
;									Cyclone. Initialize dbLite docking bar and scsi disk mode. Check
;									for LCD screens instead of PowerBook 170 boxflags. Added New Age
;									driver installation code. Deleted some old SE30 patch. 
;									¥¥¥ LCDScreenChk, SCSIDiskMode commented out temporarily.
;	  <SM15>	 5/23/92	RB		Changed a bsr to bsr.l, also made the SuperMario ROM release id
;									field a word, so I had to change its location.
;	  <SM14>	 5/22/92	FM		Turned off vectorization temporarily
;	  <SM13>	 5/21/92	RB		Defined the location for the SuperMario ROM version which will
;									be used to determine which vectors to load from disk.
;	  <SM12>	 5/21/92	kc		Append "Trap" to the name of DTInstall to avoid name conflict
;									with the glue.
;	  <SM11>	 5/16/92	kc		Roll in Horror changes. Comments Follow: ¥ÊFrom StartInit.a ¥
;		<H7>	  4/8/92	SWC		Modified InitHiMemGlobals to force BufPtr to be at least
;									"bufWorldSize" bytes (currently 8K) below the top of RAM so
;									Macsbug won't load into [DBLite's] sound buffer and get trashed
;									when a sound is played.
;		<H6>	 2/19/92	JC		Define PatchFlags in unused byte of ROM header ($0014).
;		<H5>	 2/12/92	SWC		Added a call to InitCrsrDev in InitCrsrMgr so that the new mouse
;									acceleration stuff can be installed. Moved call to InitCrsrMgr
;									to just after ExpandMem is initialized since the CrsrDev stuff
;									keeps its globals there.
;		<H2>	 9/10/91	CMP		Overpatched InitIWM to handle SWIM2 chip
;									¥ÊFrom PwrControlsPatches.a ¥
;	   <H14>	 4/24/92	HJR		Provided Econo-Mode support for Niagra.
;	   <H10>	 3/16/92	SWC		Added support for 33MHz MSC systems to CheckEconoMode.
;		<H9>	 2/21/92	HJR		Modified check sleep to use new ram locations instead of
;									obsolete VRam space.
;		<H8>	 2/10/92	HJR		Fix a bug where we are returning from a BSR6 without setting the
;									return address in A6.
;		<H7>	  2/7/92	SWC		Modified the CheckEconoMode code to lookup the correct base
;									Power Manager PRAM address from the primitives tables.
;		<H6>	 1/24/92	SWC		In CheckEconoMode, do both econo-mode setup and chip
;									configuration for the MSC case.
;		<H2>	  8/8/91	SWC		Added import of USTPMGRSendCommand and modified the econo mode
;									code to use it instead of sending the bytes discretely.
;									Universalized the ADB code so that it supports interrupts on CA2
;									and PMGR auto-polling for DB-Lite.  Fixed PortableCheck so it
;									handles the case when VRAM doesn't retain power across sleep
;									(state saved in PMgrGlobals).  Added EnableSCSIIntsPatch so we
;									won't enable SCSI interrupts on DB-Lite.
;									¥ÊFrom StartInitPatch.a ¥
;		<H7>	12/18/91	SWC		Modified InitSWIM2 to check for the existance of registers as
;									well as doing a bus error check since the final MSCs in DB-Lite
;									don't generate a bus error if the chip isn't there.
;		<H5>	10/30/91	SWC		Added a check to InitSWIM2 to first check if the chip is even
;									installed (bus error) to support DB-Lite where the SWIM chip is
;									on an external board that may or may not be connected at startup
;									time.
;		<H2>	 9/11/91	CMP		Added InitSWIM2 to support SWIM2 chip.
;	  <SM10>	 4/22/92	RB		Added a call to vector initialization routine of the Window
;									Manager, which is temporarily vector $2000. This is for
;									experimentation.
;	   <SM9>	 4/15/92	RB		The 040 BlockMove was fixed almost immediately after I broke it.
;									So I am re-enabling that code back. Removed the bullets in
;									comment in <SM3> so that we know it's been taken care of. Also
;									re-enabled 040 caches.
;	   <SM8>	 4/14/92	kc		Remove call to BTreeInstall.
;	   <SM7>	 3/24/92	PN		Add new soundmgr init into the existing soundmgr initialize
;									routine. Disable 040 caches.
;	   <SM6>	  3/4/92	kc		Remove the 7.0 manager initialization calls.
;	   <SM5>	  3/4/92	PN		Adding a vector for InstallMgr
;	   <SM4>	  3/4/92	kc		Add call to _InitFS and comment out call to the install TimeMgr
;									patch.
;	   <SM3>	  3/4/92	kc		Rearange the ordering to get around interdependencies. Added the
;									code from StartBoot.a that initializes the managers 
;									 We need to fix the 040 BlockMove 
;	   <SM2>	 2/12/92	RLM		Roll in PatchMDJGNEFILTER PatchProc. 
;									¥ Pre-SuperMario Comments Follow ¥
;		<71>	 1/30/92	KC		(Really JSM) Change low byte of ROMVersion to $7D just to be
;									really different from $067C.
;		<70>	 1/27/92	KC		Fix bug in cpu test (change blt.s to bne.s).
;		<69>	 1/27/92	KC		Remove call to InitNonMMU, and added runtime cpu check in
;									SwitchMMU.
;		<68>	 1/23/92	KC		Roll in Zydeco patches from StartInit.a and StartInitPatches.a
;									From StartInit.a and StartInitPatches.a
;		{30}	 5/31/91	djw		 (for SWC) Call InstallSonyDriverPatch (StartInitPatches.a) to
;									 check for the existence of either an IWM/SWIM or SWIM IOP before
;									 installing the floppy driver (for systems without floppy
;									 drives).
;									From Zydeco StartInitPatches.a: (original comments were missing)
;									 Added hasEDisk and forRomulator conditionals.
;									 Removed call to InitOverPatch and InitVidGlobals.
;									 Removed InitVidGlobals stub.
;									 Rolled in OpenNetBootPatch and EDiskPatch2 and ConfigureRAMPatch.
;									 Changed WhichCPU to use the data instead of instruction cache.
;									 Added code to check location of boot globals in InitHiMemGlobals.
;									 Added InitNonMMU and CheckForEgretOrCuda and call to
;									 InitEgretAlt which were deleted in last revision.
;									 Moved call to GetPRAM to before the call to InitMemMgr.
;									 Added call to InitMemoryDispatch, InstallPrivTrap, InstallFPSP and InitNonMMU.
;		<67>	 1/15/92	KC		Fix comment from last checkout.
;		<66>	 1/15/92	KC		Resolve BootGlobals name collision caused by moving the
;									BootGlobals record into BootEqu.a (changed BootGlobals to 
;									BootGlobalsSize & QDBootGlobals to QDBootGlobalsSize).
;		<65>	  1/3/92	RB		Install an optimized BlockMove for 68040 based CPUs.
;		<64>	12/31/91	RB		Use RAMConfigBase only on HcMac
;		<63>	12/30/91	RB		Need to export INITSNDNORAM since the new boot beep code calls
;									it.
;		<62>	12/29/91	RB		Removed the implementation of ElsieTranslate24to32 since it is
;									in a QuickDraw file too.
;		<61>	12/27/91	RB		Open backlight driver on machines with Power Mgr.
;		<60>	12/27/91	RB		Added Terror changes.
;		<59>	11/16/91	DTY		Replacing hard addresses with a record to make the equates 'more
;									universal' is nice but useless if the code has no way of getting
;									to those addresses any more.  Add equates for VidRAMSleepFlag
;									and VidRAMWakeVect to this file to keep the ROM build building
;									until the hardware guys figure out what they're trying to do.
;		<58>	10/17/91	JSM		Get rid of all the stupid conditionals.
;		<57>	 10/2/91	JSM		Use MemoryMgrPriv.a instead of HeapDefs.a.
;		<56>	 10/1/91	JSM		Don't use onMvMac conditional, Modern Victorian never existed.
;		<55>	 10/1/91	JSM		Don't use hasADB conditional, all future ROMs will support ADB.
;		<54>	 10/1/91	JSM		Don't use eclipseDebug.
;		<53>	 9/30/91	JSM		Don't use is32BitClean conditional, all future ROMs will be.
;		<52>	 9/27/91	JSM		Don't use hasCQD conditional, all future ROMs will have color
;									QuickDraw.
;		<51>	 9/16/91	JSM		Cleanup header.
;		<50>	 6/12/91	LN		Changed #include 'HardwareEqu.a' to 'HardwarePrivateEqu.a'
;		<49>	 5/21/91	gbm		Nail a couple of warnings
;		<48>	 12/7/90	dba		Institute dead-code stripping.
;		<47>	10/22/90	JJ		Rex V8: Change VISAChipBit to V8ChipBit.
;		<46>	 9/24/90	BG		Changed the code at the very very start of the ROM that
;									determines whether or not the CPU involved is an 040. The code
;									first used the 040 Data Cache Enable bit in the CACR <19>, but
;									that was switched when earlier versions of the 040 died
;									immediately upon turning on the data cache. However, the correct
;									bit to use is the data cache enable bit, and this mod. switches
;									back to using that. Also changed various ugly raw constant
;									references of bits set/tested/etc. in the CACR to symbolic
;									constants defined in HardwarePrivateEqu.a.
;		<45>	 9/19/90	BG		Removed various 040-related kludges. 040s are behaving more
;									reliably now.
;		<44>	 9/14/90	MSH		Put in a fancy new universal check for wake from sleep (ok, its
;									not really elegant, you got a better idea?).
;		<43>	  9/1/90	BG		Updated to handle Eclipse EVT1 board.  Specifically - Egret
;									lowmems were only initialized if the Universal tables say that
;									we have ADBEgret.  We also needed to initialize them if we have
;									ClockEgret.
;		<42>	  7/4/90	CCH		Added check to SetupHiMemGlobals to move bootglobs if its above
;									ROM (when ROM is in RAM) and added a check that skips SCC
;									initialization if running from RAM.
;		<41>	  7/3/90	BG		Turn off 040 caches if we*re running from RAM.
;		<40>	  7/2/90	jmp		Made no changes, accidently checked out file.
;		<39>	 6/28/90	BG		Rolled in changes for Eclipse/040.
;		<38>	 6/12/90	NC		Add the calls to init all the Sound I/O Manager stuff correctly.
;		<37>	  5/8/90	JJ		Added code to disable the MemoryDispatch trap if the machine has
;									no MMU or has an HMMU.
;		<36>	  5/3/90	GMR		ConfigureRAM now merges contiguous RAM chunks into a single
;									chunk.
;		<35>	  5/1/90	DAF		Removing ELSIE Huge Hack to BufPtr
;		<34>	 4/21/90	GMR		Moved ConfigureRAM functionality to SizeMem.a, to solve problems
;									with writing the chunk table before stitching occurs. Before,
;									pages within a bank might swap (depending on bank size/location)
;									after stitching, causing the chunk table to no longer be at the
;									end of the bank.
;		<33>	  4/4/90	MSH		Removed universal test around InitPmgrVars.
;		<32>	  4/4/90	JJ		Temporary hack to make "special" setting of BufPtr take place on
;									Elsie.
;		<31>	 3/29/90	MSH		Added universal test for Pmgr initialization.
;		<30>	 3/27/90	JJ		Fixed bugs in ConfigureRAM code for VISA II.
;		<29>	 3/23/90	JJ		Replaced VISA I code in ConfigureRAM with code for both VISA I
;									and VISA II.
;		<28>	 3/22/90	JJ		Change reset vector to begin execution in overlay ROM space
;									rather than actual ROM space.
;		<27>	 3/22/90	MSH		Changes to clock.a require small modifications to the PRAM
;									calls.
;		<26>	 3/21/90	SS		Removed the Egret initiatlization code.  I moved it into
;									USTStartUp.a after the RAM tests.
;		<25>	 3/13/90	GA		Added a call to Egret to Stop AutoPoll and one second interrupts
;									prior to running Diagnostics.
;		<24>	 2/28/90	JJ		Added code to install ElsieTranslate24To32 routine as the
;									Translate24To32 trap on machines with VISA decoders.
;		<23>	 2/28/90	GMR		Changed Egret run time checks to use new equates.
;		<22>	 2/20/90	CCH		Updated some comments.
;		<21>	 2/20/90	CCH		Added routine to configure Orwell memory controller to
;									ConfigureRAM.
;		<20>	 2/19/90	NC		Put in initialization calls to the 7.0 Sound Manager if on a
;									machine with Egret. THIS WILL CHANGE WHEN A REAL FLAG IS
;									AVAILABLE!
;		<19>	 2/16/90	BG		Modified cache testing and enable/disable instructions not to
;									use the 040 data cache since it is non-functional in the current
;									rev. of the 040 silicon. Switched usage of DE to IE in places
;									where it matters.
;		<18>	 2/11/90	GA		Added endwith to with statements inside hasEgret conditionals
;		<17>	  2/9/90	BG		Added code to enable 040 caches.
;		<16>	  2/9/90	JJ		VIA CPU ID bits $1110 assigned to Elsie.  Modified InitSCC to
;									avoid addressing location 1 below SCC base address.  SCC reset
;									now done by sending $C0 command to SCC.  Add routine for VISA
;									decoder to ConfigureRAM.  Force result of CompBootStack to be
;									even.
;		<15>	  2/4/90	CV		HwCfgFlags gets read from d2, not from the universal tables.
;									With an optional FPU, the table may not have the correct value.
;		<14>	  2/4/90	GA		Added Calls to InitEgret and conditionals with Universal runtime
;									checks.
;		<13>	 1/15/90	BG		Corrected the enabling the of the instruction cache in WhichCPU.
;									Also modified comments in WhichCPU, SwitchMMU to reflect
;									reality.
;		<12>	 1/14/90	GGD		NEEDED FOR ZONE-5: Changing the order of reset/mmu disable at
;									start time to prevent possible double bus errors on machines
;									with overlay bits. Also fixed a few bugs in the 040 detection
;									code.
;		<11>	 1/11/90	CCH		Added include of 'HardwarePrivateEqu.a'.
;		<10>	 1/10/90	BG		Updated WhichCPU to recognize 040s.
;		 <9>	  1/9/90	BG		Change StartBoot to be run-time detection of 040s instead of
;									assembly-time for universality.
;		 <8>	  1/8/90	BG		Changed the code at StartBoot so that it does the correct thing
;									for the 040.  Unfortunately, this is an assembly-time change
;									(for now) because the way you deal with the TC register is
;									radically different than on the 020/030, and the 040 CACR looks
;									and acts differently than the 020/030.
;		 <7>	  1/6/90	BG		Updating MMU- and Cache-related code to work correctly on the
;									040. This is assembly-time conditionalized for now but will be
;									changed to Runtime checking later (where possible).
;		 <6>	  1/4/90	BG		Adding MACHINE MC68040 directive into the SETMACHINE macro. This
;									will only be invoked if CPU = 040, a condition no one should be
;									seeing unless you do a -Mac040- build.
;		 <5>	12/27/89	SWC		Forgot to include a "WITH DecoderInfo" for the parity stuff.
;		 <4>	12/26/89	SWC		Replaced "#"s with ";"s for the following comment since the
;									AddChange script was messed up when this file got checked in.
;		 <3>	12/26/89	SWC		Setup FMC configuration to do the right thing for both parity
;									and non-parity systems.
;		 <2>	12/21/89	CCH		Fixed up comment header.
;	  <11.7>	11/28/89	SWC		Removed references to FMCRev2 since Zone 5 has the final version
;									of its memory controller.
;	  <11.6>	11/15/89	GMR		NEEDED FOR ZONE-5. Added call to EnableParityInts that sets the
;									OSS RPU's mask reg to level 7 if the RPU is present.
;	  <11.5>	11/10/89	MSH		Rolled in support for both black fill and white fill for hcmac
;									NTSCmode.
;	  <11.4>	10/31/89	PWD		Restore stack pointer after checking if the netBoot driver is
;									there before _Opening it.
;	  <11.3>	10/31/89	MSH		Took the conditional assembly of TEGlobalInit out, now always
;									assembles. Changed
;	  <11.2>	10/31/89	PWD		Added net booting. Just Opens the driver after the .Sony driver.
;	  <11.1>	 8/23/89	SES		Temporarily add MBProcHndl to this file until all nfile
;									references in all sources are removed. Once nFiles are removed,
;									MBProcHndl should be put into ToolEqu.a.
;	  <11.0>	 8/22/89	SES		Removed references to nFiles. Changed include DeclRomEqu.a to
;									RomEqu.a.
;	  <10.9>	 8/22/89	GMR		Removed RunDiags, always call universal StartTest diags now.
;									Prep A2 with VIA1 base before calling quasiPwrMgr when reading
;									RamDisk size, to work with universal RdXByte.
;	  <10.8>	 8/16/89	BBM		made EDisk open on feature 'hasEDisk', rather than the hack
;									onHcMac.
;	  <10.7>	 7/27/89	CCH		Fixed _real_ bug that was trashing a4 in configureRam, and
;									restored fixAddr.
;	  <10.6>	 7/27/89	CCH		Fixed bug in fixAddr that was using address of bank B as it's
;									size.
;	  <10.5>	 7/25/89	CCH		Modified configureRAM for glue chip and FMC based machines to
;									adjust universal info pointers and return address on stack if
;									their addresses change as a result of setting memory size bits
;									when forRomulator flag is set.
;	  <10.4>	 7/17/89	GGD		Fixed comment from last change, added call to InitOverPatch.
;	  <10.3>	 7/16/89	GGD		NEEDED FOR AURORA: Modified the Reset PRAM key sequence to
;									preserve the Reliability manager PRAM bytes, but invalidate all
;									others.
;	  <10.2>	 7/14/89	djw		NEEDED FOR AURORA: Removed getting warmstart in initslots - now
;									done in startsdeclmgr.
;	  <10.1>	 7/14/89	SWC		NEEDED FOR AURORA: Changed CACR setup so that bursting is
;									disabled only on F-19s with old FMCs.
;	  <10.0>	 7/13/89	GGD		Added check for Cmd-Opt-R-P keys at boot time to Reset PRAM, in
;									case PRAM contents prevents booting for some reason.
;	   <9.9>	  7/8/89	CCH		Modified to work with Romulator.
;	   <9.8>	  7/6/89	GGD		Un-Proc'd WriteSCC because code falls into it, and alignment
;									would screw it up. Changed the FMC rev 1 vs 2 code to produce
;									code that is the same size in both cases. Added some padding for
;									overpatching.
;	   <9.7>	  7/5/89	CCH		Added ROM build version to ROM Header.
;	   <9.6>	 6/30/89	rwh		handle memory sizes not supported by hardware on FMC, GLU
;									machines.
;	   <9.3>	 6/30/89	CSL		initialize new low mem LockMemCt to zero. Also removed
;									Dispatcher vector from Foreign OS vector table
;	   <9.2>	 6/30/89	smb		NEEDED FOR AURORA: Added call to TEGlobalInit for TE vectors
;									stored in ExpandMem.
;	   <9.5>	 6/30/89	DAF		Added additional error checking to gamma loading routines to
;									prevent allocation of garbage on cards w/o gamma directory
;	   <9.4>	 6/30/89	CSL		Fixed bug in SysHoleheap, field for cMoreMasters should be size
;									word, not size long. and put conditional around TEGlobalInit to
;									exclued HcMac.
;	  <¥9.5>	 6/30/89	DAF		Overriden again! There wasn't enough room on Reality to submit
;									before!
;	  <¥9.5>	 6/30/89	DAF		Override submission because of network problems
;	   <9.1>	 6/29/89	rwh		Needed for AURORA: handle Bank B size > bank A for glu chip
;									machines. Marked 9.0 changes.
;	   <9.0>	 6/28/89	rwh		NEEDED FOR AURORA: moved MMU switch code to Foreign OS table.
;									Cleaned up comments near start for the BootGlobals way.
;	   <8.9>	 6/27/89	rwh		NEEDED FOR AURORA: changes to get FMC rev 2 working. Removed
;									RoundUp of screen buffer sizes, since we wrap before AND after
;									video buffer now. Changed error codes in CheckSize, but still
;									need equate!
;	   <8.8>	 6/26/89	GMR		Exported StartTestFlags.
;	   <8.7>	 6/20/89	SWC		Replaced immediate constant with lomem variable for HcMac in
;									DrawBeepScreen.
;	   <8.6>	 6/16/89	SWC		Save and restore registers around ValidatePRAM call.
;	   <8.5>	 6/16/89	CSL		Moved ValidatePRAM to after StartTest.
;	   <8.4>	 6/15/89	SWC		Added a call to ValidatePRAM (Clock.a) to make sure PRAM's got
;									good stuff in it.
;	   <8.3>	 6/13/89	DAF		Moved routine which calculated dead mac's top left corner inline
;									into StartFail.a
;	   <8.2>	 6/12/89	rwh		corrected comment in FixAddr. Fixed setting of Glu size bits in
;									ConfigureRam. Added register usage comments in ConfigureRam.
;									Fixed booting in 24 bit mode w/>8mb RAM. Made InitSlots switch
;									to 32 bit mode to access BootGlobs.
;	   <8.1>	 6/12/89	djw		Added universal slot zero pram support in GetRBVSize. GGD got
;									Mac SE Rom in Ram working again.
;	   <8.0>	 6/11/89	GGD		Updated to use new Video, hwCfgFlags, and ROM85 info from
;									Universal Rom tables.
;	   <7.9>	 6/11/89	GMR		Added call to universal StartTest diagnostics, in place of
;									'fake' diags.
;	   <7.8>	 6/11/89	GMR		Added some BIG Jmp/Jsr's to fix link errors. Fixed initNonMMU to
;									handle bad RAM disk size.
;	   <7.7>	 6/10/89	GGD		Updated box flag names.
;	  <¥7.6>	 6/10/89	SWC		Initialized screen dimension lomems for Mac Plus/SE so that they
;									can be used consistently on all machines. Fixed a bug in
;									SetupHWBases (wrong bit tested). Always include ColorEqu.a
;									(instead of conditional on hasCQD). Got rid of TestInRAM and
;									associated code at StartBoot. Initialize BootGlobPtr on all
;									machines so that the warmstart flag can be saved. Moved
;									InitPmgrVars to PoweResourceMgr.a. Fixed a bug in InitNonMMU: A6
;									was getting trashed. Bad dog, rwh!
;	   <7.4>	 5/31/89	rwh		removed some orphan code from ConfigureRam (sloppy!)
;	   <7.3>	 5/30/89	DAF		Updated InitDefGamma to use the card ROM's gamma directory if
;									present
;	   <7.2>	 5/30/89	rwh		made ConfigureRam set up 'offset to top of bank' field in boot
;									globals, and put stack halfway thru 1st bank of RAM. Change
;									InitNonMMU to get at RAM chunk table using a6 instead of sp.
;									Fixed conditional around import from change 7.1.
;	   <7.1>	 5/30/89	CSL		moved code to enable external cache to HWPriv.a and called the
;									routine. Changed RunDiags to not run Aurora diags on NuMac
;									machines.
;	   <7.0>	 5/29/89	GGD		Added runtime test to InitIWM to only call it if an IWM/SWIM
;									exists. Added the ROM version number for all 32 bit universal
;									roms. ($7C same as Aurora) Added check to see if StartTest
;									matches machine we are running on, and only run it if there is a
;									match. Added a fake StartTest for all other cases, which just
;									beeps and sizes memory for now. Converted to a few more feature
;									base conditionals. Removed the Alternate Diag Rom check for
;									020/030 machines, since it couldn't possibly work, and we were
;									just branching around it. Added temporary runtime check for F19,
;									to not enable bursting. Added call to SCCIOPHwInit in InitSCC
;									for IOP based machines. Added special case runtime test for the
;									SE30 only to undo the patching that the SE30 video driver Open
;									call installs to the Sony Driver ICON information.
;	   <6.9>	 5/26/89	rwh		oops! never added call to ConfigureRam!
;	   <6.8>	 5/26/89	rwh		added Reliability Manager. Moved ConfigureRam from MMU.a to
;									here, w/ggd's changes from version 2.3. Improved field names in
;									BootGlobs, replaced FixMeLater's w/ BootGlobPtr's. Changed
;									CompBootStack, SetUpSysAppZone to handle 'black hole' before
;									system heap. Fixed bug in InitHiMemGlobals's clip of memory at 8
;									meg for 24 bit mode.
;	   <6.7>	 5/26/89	GGD		Added some BIG Lea/Jsr to fix link errors.
;	   <6.6>	 5/22/89	GMR		Added InitNonMMU routine, to setup registers [a4-a6] so builds
;									will run on hcMac and MacPP again.
;	   <6.5>	 5/20/89	GGD		Changed SetupHWBases to initialize SCCrd/wr, and IWM, using
;									table info, since the IOP base addresses now point to the bypass
;									mode register base. Changed conditional on parity code to allow
;									IoMac to build again. Added universal support to the IOP manager
;									initialization routine.
;	   <6.4>	 5/16/89	rwh		fix GetRBVsize - coupla missing lines 'o code
;	   <6.3>	 5/16/89	rwh		Added code to enable external cache on MDU based systems (ggd).
;									Removed call to BootBeep, Start test does it now. New GetRBVSize
;									courtest dave fung. Changed many bsr's to BigJsr's to fix link
;									errors. Added save of parity enable state on via across call to
;									InitVias. Put stack in middle of 1st bank before calling
;									InitMMU. Deleted calls to RamTest, as all memory testing now
;									done in Start Test. Added MMU switch sky hook for Pink & A/UX.
;									Removed ALL Ramtest calls, Start Test tests all of RAM now. For
;									csl, when in 32 bit, change Translate24to32 to an rts.
;	   <6.2>	 5/15/89	GGD		Saved and restored A5 around call to BootBeep, to fix MacPP
;									builds. Removed the procedure InitADBVars, which is now done as
;									part of InitADB.
;	   <6.1>	 5/14/89	rwh		fixed bad MACHINE directives for 68000 builds
;	   <6.0>	 5/14/89	rwh		changes for universal MMU setup: call InitMMU instead of
;									MapAddress. With boot globals, can save & restore less
;									information around various RAM tests.
;	   <5.9>	 5/10/89	CCH		Added test for Mac II's when running in RAM that will give
;									GetHardwareInfo a hint that it's running on an 020 machine, so
;									it will not twiddle VIA bits which turn off the MMU. Also figure
;									out memory size in startinit when running out of RAM.
;	   <5.8>	 4/30/89	GGD		Implemented new improved table driven, universal, SetupTimeK
;									routine. Reworked InitSlots to remove calls to routines that
;									were eliminated from SIntCore. Removed hardware dependencies,
;									and called universal routines to enable and disable various
;									interrupt sources. VIA and hardware base initialization are now
;									done using universal ROM tables and routines The Low memory
;									globals for hardware base addresses are now kept updated
;									throughout StartInit, to allow routines to be more universal.
;									WhichBoard now uses universal rom information. WhichCPU
;									completely re-written to not use low mem exception vectors.
;									Changed MapAddress to preserve some registers across the call,
;									and re-arranged some of the registers that is uses to abtain
;									that. Added call to JumpIntoROM to find the ROM and machine
;									info. Removed old test for hard reset.
;	   <5.7>	 4/28/89	CSL		Initialized Phys2Log for Physical to logical convertion value
;									for MMU table. PhysicalRAM and SystemRAM is renamed to
;									PhysMemTop and RealMemTop.
;	   <5.6>	 4/27/89	CCH		Added changes to make Romulator work.
;	   <5.5>	 4/24/89	MSH		Gave everyone but Mac Plus the latest SCC init table data.
;	   <5.4>	 4/18/89	CCH		Added changes for Rom in Ram to work.
;	   <5.3>	 4/17/89	CSL		Added 2 vectors for A/UX, for Dispatcher and StartSDeclMgr, also
;									initialize two new lo mem PhysicalRAM and SystemRAM.
;	   <5.2>	 4/14/89	GMR		Disable ADB interrupts in BootRetry. Later InitADB is called to
;									set up the handler and re-enable them.
;	   <5.1>	 4/13/89	MSH		InitPmgrVars uses a new power manager command ($21) to clear ADB
;									autopolling.
;	   <5.0>	 4/13/89	GGD		Changed OSS interrupt mask initialization to use new names from
;									hardwareEqu. Added initialization of new VIA2RBVOSS lowmem, and
;									changed various routines to get base addresses from memory
;									instead of using absolute addresses. Started converting to
;									feature based conditionals. Made Foreign OS tables available on
;									all CPUs. Cleaned up comment and code for the 4 bit CPUID field
;									extraction.
;	   <4.9>	  4/7/89	MSH		InitPmgrVars disables auto polling, loads pmgr interrupt
;									handlers, and enables pmgr interrupts. Also backed out change
;									4.8. StartTest will clear warmstart if a hard reset ocurred.
;	   <4.8>	  4/4/89	SES		Added check for PwrMgr reset on HcMac. If PwrMgr reset occurred,
;									then Ram test is run regardless of warmStart value.
;	   <4.7>	  4/3/89	MSH		Clear MMUType if no mmu exists. This area needs work to support
;									all combinations of MMUs, processors, and accelerators.
;	   <4.6>	 3/31/89	SES		Added some BigJSRs & BigLEAs for IoMac & MvMac.
;	   <4.5>	 3/31/89	MSH		Made battery monitor into sound monitor vbl task.
;	   <4.4>	 3/28/89	SES		Moved MapAddress above first call to RAMtest. For hcMac, hafMac
;									and mvMac StartInit is once again making the calls to RAMtest,
;									but BootBeep is still called in StartTest.
;	   <4.3>	 3/24/89	CCH		Added RomLoc location in Rom Header to hold information on where
;									ROM is executing from (i.e. Ram, Emulator).
;	   <4.2>	 3/22/89	CSL		Turn on Burst mode for I/D cache, also ROMmap is now a 32 bit
;									heap, also fix slimy RockWell VIA bug by saving output reg. A in
;									WhichBoard routine. New code to replace SwapMMUmode with
;									SwapMMU32only for pure 32 bit only addressing.
;	   <4.1>	 3/14/89	MSH		Added Esprit ASIC register init that was pulled for starttest.
;	   <4.0>	  3/9/89	MSH		Updated an equte in init pmgr vars.
;	   <3.9>	  3/6/89	GGD		Modified InitIWM to force SWIM chip to switch into IWM mode to
;									prevent looping if SWIM did not get reset properly (HcMac does
;									not do a RESET on restart, and has problems) Added deferred task
;									manager for onMacPP. Moved InitXVectTables to
;									InterruptHandlers.a, and renamed it InitIntHandler. Added
;									conditional support for Ram based onMacPP rom image. Added an
;									extra entry in the ROM header for HiRam to use to insert the ROM
;									Size. Contimued effort to make the ROM position independent,
;									allowing for an initial PC that assumes the ROM is mapped to
;									zero at start time, and the jumps into the real ROM space.
;									Changed RBV register usage now that equates are offsets from
;									RBVBase, instead of being absolute addresses.
;	   <3.8>	  3/3/89	CCH		Now initializes expandMem and Gestalt.
;	   <3.7>	  3/3/89	MSH		Initialize LastAct and LastHd to 1.
;	   <3.6>	  3/2/89	jwk		Adding "BigJSR INITADB" so that IoMac will build.
;	   <3.5>	  3/1/89	MSH		Cleaned up topanga support.
;	   <3.4>	 2/28/89	CSL		Added support for 32 bit clean memory manager.
;	   <3.3>	 2/27/89	CSL		changed RBV on board video from slot E to slot 9 for DVT and
;									later machines.
;	   <3.2>	 2/21/89	CSL		changed movea to movea.l in MapAddress.
;	   <3.1>	 2/16/89	rwh		added support for Fitch Memory Controller rev 1, which has a
;									split memory model like MDU. WHen FMC2 arrives (contiguous
;									memory), remove these changes. Removed conditionals for
;									non-working Vias.
;	   <3.0>	 2/16/89	SES		Jumped around the remaining Ram test for hafMac. Will revisit
;									later.
;	   <2.9>	 2/14/89	SES		Jumped around a memory test and bootbeep for HafMac since they
;									are currently being done by the StartTest files.
;	   <2.8>	 2/14/89	rwh		made some lea's & bsr's into BigLea's and BigJsr's to fix link
;									problems. Fixed
;	   <2.7>	 2/10/89	rwh		Oops! Appletalk checks for ROM version ³ 76 for presence of
;									Start Manager (with
;	   <2.6>	  2/9/89	CCH		Made version numbers of HafMac, HcMac, and MvMac all $01, since
;									this is the first iteration of each ROM.
;	   <2.5>	  2/8/89	SGS		Added support for SCC IOP
;	   <2.4>	  2/8/89	MSH		dded support for Topanga video interface converter. NTSC
;									monitors require a narrowed
;	   <2.3>	  2/6/89	rwh		Fix MapAddress: on 4Mb 4Square, 1st entry in 1st level 32 bit
;									mode table 2nd
;	   <2.2>	 1/30/89	cv		Added Spin as a CPU type
;	   <2.1>	 1/28/89	GGD		Added scratch register to new BigLEA/JMP/JSR macros to be
;									position independent. Fixed assembly error, and logic errors in
;									Mac II class board id routine.
;	   <2.0>	 1/25/89	rwh		rewrote parts of WhichBoard to generalize for newer 4 bit id
;									machines. Fixed two bugs in MapAddress for MDU machines w/o
;									onboard video.
;	   <1.9>	 1/23/89	CSL		put conditional around setting MMU24Info
;	   <1.8>	 1/23/89	CSL		Initialize MMU24Info to point to the physical address of the MMU
;									table
;	   <1.7>	 1/20/89	CSL		Generate MMU tables for any RAM configurations, for both 24 bit
;									and 32 bit mode.
;	   <1.6>	12/15/88	GGD		Added initialization of TimeVIADB and VIA2RBV low mems.
;	   <1.5>	12/14/88	MSH		Changed VIA interrupts to be independent active negative edge.
;	   <1.4>	12/13/88	rwh		added startup of IOP Scc in InitSCC. Must be done before
;									calculating TimeSccDb. Even though IOP is in bypass at reset,
;									timing differs when it is running.
;	   <1.3>	11/23/88	rwh		Added cache enables after last call to RamTest.
;	   <1.2>	11/17/88	GGD		Deleted code for InitDispatcher and BadTrap, they are now
;									located in Dispatch.a Changed GoofyDoEject to do a BigJMP so
;									that TFS code can move away some more.
;	   <1.1>	11/10/88	CCH		Fixed Header.
;	   <1.0>	 11/9/88	CCH		Adding to EASE.
;	   <3.1>	 11/6/88	GGD		Ported to IoMac.
;	   <3.0>	 11/1/88	MSH		Moved the init of the deferred task manager out of slot init.
;									Now anyone can use it.
;	   <2.9>	10/24/88	CSL		added temporary address translation table for RBV RAM based
;									screen buffer.
;	   <2.8>	 10/7/88	rwh		changed some MvMac, MMU, ADB and generic 020/030 stuff to
;									feature based conditionals. Made sound, IWM base addr name
;									uniform on all machines.
;	   <2.7>	 10/5/88	CSL		Added support for RBV and MDU.
;	   <2.6>	 9/29/88	MSH		Flagged time outs to be dirty when allocated so they get updated
;									later.
;	   <2.5>	 9/24/88	rwh		oops - fix 2.4's missing ENDIF in non-onMvMac builds.
;	   <2.4>	 9/24/88	rwh		roll in onMvMac changes. Note that InitADB moved to after
;									InitIOMgr to support Gary's IOP based ADB implementation.
;	  <¥2.3>	 9/23/88	CCH		Got rid of inc.sum.d and empty nFiles
;	   <2.2>	 9/12/88	rwh		Fix WhichBoard so it builds for onHcMac.
;	   <2.1>	 9/10/88	rwh		Roll in of Mac IIx changes: New WhichCPU routine.
;									InitHiMemGlobals pegs BufPtr to 8 Meg or less. CompBootStack
;									uses BufPtr, not MemTop, for ALL machines. Ensure RAM tests are
;									done in 32 bit mode for >8 Meg machines. Add WhichBoard routine,
;									BoxFlag global for identification of logic board. Turn off 030
;									MMU at start of HW Init sequence. Remove obsolete Rev8Chk
;									routine & calls to it.
;	   <2.0>	  9/9/88	MSH		Added initialization of lomem value screenbytes for hcmac.
;	  <1.15>	  9/8/88	MSH		Moved allocation and initialization of Pmgr vars. Added read of
;									sleep and hard disk time outs from pram into pmgr locals.
;	  <1.14>	 8/16/88	GGD		Moved Time Manager initialization into TimeMgr.a.
;	  <1.13>	  8/5/88	MSH		Removed useless Speedometer setting
;	  <1.12>	 6/24/88	MSH		New equate used for turning off everything at end of init for
;									HcMac.
;	  <1.11>	 6/15/88	MSH		Removed ram testing and boot beep, now done in StartTest for
;									HcMac. StartTest returns start of RAM Disk in A5 in on HcMac.
;									Use instead of MemTop. Removed the eyebrows from the startup
;									gray screen.
;	  <1.10>	 5/27/88	MSH		Restored video ram test temporarily and fixed stack
;									initialization.
;	   <1.9>	 5/26/88	MSH		Moved NMInit IMPORT to MyROM PROC.
;	   <1.8>	 5/26/88	MSH		Took out redundant ram testing and fixed the ASC interrupt clear
;									for HcMac.
;	   <1.7>	 5/25/88	MSH		Added EDisk driver open for Laguna.
;	   <1.6>	 5/23/88	BBM		Put NMgr init code in proper place (after traps inited).
;	   <1.5>	 5/23/88	BBM		added code to initialize the Notification Manager.
;	   <1.4>	 5/19/88	BBM		Fixed reference to GNEFilter.
;	   <1.3>	 5/16/88	BBM		Use alarm code from Notification Manager. cleaned up comments.
;	   <1.2>	 4/25/88	MSH		Clear pending ASC interrupt for HcMac
;	   <1.1>	 4/18/88	CSL		Need to turn off serial drivers at end of boot. Initialize
;									speedometer to 16 mhz.
;	   <1.0>	 2/10/88	BBM		Adding file for the first time into EASEÉ
;__________________________________________________________________________________________________

			PRINT		OFF
			LOAD	'StandardEqu.d'
			INCLUDE	'HardwarePrivateEqu.a'
			INCLUDE	'MemoryMgrPriv.a'
			INCLUDE	'SCSI.a'
			INCLUDE	'MMUequ.a'
			INCLUDE	'BootEqu.a'						; Must appear after MMUEqu.a

			INCLUDE	'ROMEqu.a'
			INCLUDE	'SlotMgrEqu.a'
			INCLUDE	'Video.a'
			INCLUDE	'DepVideoEqu.a'

			INCLUDE	'ColorEqu.a'
			INCLUDE	'UniversalEqu.a'
			INCLUDE	'ReliabilityEqu.a'
		IF hasEgret THEN
			INCLUDE	'EgretEqu.a'
		ENDIF
			INCLUDE	'EDiskEqu.a'
			INCLUDE	'SCSIEqu96.a'
		IF hasPwrControls THEN
			INCLUDE	'PowerPrivEqu.a'
		ENDIF
			INCLUDE	'PSCEqu.a'						;														<SM16>
			INCLUDE	'IOPrimitiveEqu.a'						;														<SM16>
			INCLUDE	'GrandCentralPriv.a'
			
			INCLUDE 'GestaltEqu.a'					;														<SM41>
			INCLUDE 'GestaltPrivateEqu.a'			;														<SM59>

		IF hasNetBoot THEN
			INCLUDE 'AppleTalk.a'					; 														<SM65>
			INCLUDE	'AtalkPrivateEQU.a'
		ENDIF
		
			PRINT	ON
			BLANKS	ON
			STRING	ASIS

		
;----------------------------------------------------------------
; Equates
;----------------------------------------------------------------

dsGNLoadFail	EQU			20011		
MBProcHndl		EQU			$D54					;put it here until we're rid of nFiles

;	During startup, the system heap is growable (since it masquerades in app's clothing).  This constant
;	specifies how much space we need beyond the suite of drivers and before the final size is specified.

MinSysExtra		EQU		128*1024						; was 16K		<SM117> CCH & joe												<SM75>

;	The boot time stack size depends on quickdraw, since there's no significant nesting of start routines.
;	WARNING -- cross-defined in StartBoot.a

BootStackSize	EQU		8*1024

;	While drawing Horst's BeepScreen, a QD world is required just below the area where the boot blocks are
;	loaded.  BootGlobalsSize gives the amount below the boot blocks buffer where the stack can begin.
;	QDBootGlobalsSize gives the amount above the stack that the A5 world can begin.  We err on the big side
;	here for slack's sake.  For example, on a megabyte machine, MemTop is $100000.  Boot blocks will arrive
;	at $80000.  Allowing $400 for boot globals and $190 (400 decimal) for QD globals, SP would be at $7FC00,
;	and A5 at $7FD90.  The utter clarity of it all!

BootGlobalsSize		EQU		$400						; 1K for QD and other globals
QDBootGlobalsSize	EQU		$190						; a mere 400 bytes for QD

; <60>, move this constants to hardwareprivateequ later...

nuBusTTxlat		EQU		$807FC040					; nubus space $8-$F with serialized writes 
;ioNuBusTTxlat	EQU		$403FC040					; ROM, I/O space and nuBus $6-$7 with serialized writes	<T19>
ioNuBusTTxlat	EQU		$500FC040					; I/O space and nuBus $6-$7 with serialized writes		<T19>			
			


			MACRO
			SETMACHINE
	IF CPU = 020 THEN
			MACHINE		MC68020
	ELSEIF CPU = 030 THEN
			MACHINE		MC68030
	ELSEIF CPU = 040 THEN
			MACHINE		MC68040
	ELSE
			AERROR		'Unknown CPU type'
	ENDIF
			ENDM


			SETMACHINE



;---------------------------------------------------
; EXPORTs and IMPORTs
;---------------------------------------------------

;	labels from other files

			IMPORT	BaseOfRom

			IMPORT	BadTrap							; Dispatch.a
			IMPORT	BlockMove68040					; BlockMove.a											<SM9>
			IMPORT	BootBeep						; BootBeep.a
			IMPORT	BootMe							; StartBoot.a
			IMPORT	CritErr							; StartFail.a
			IMPORT  CrsrDevHandleVBL				; CrsrDev.a
			IMPORT	DisableIntSources				; InterruptHandlers.a
			IMPORT	DispTable						; DispTable.a
			IMPORT	DoEject							; TFS.a
		IF hasEgret THEN
			IMPORT	EgretDFACandPDM					; EgretMgr.a											<SM16>
		ENDIF
			IMPORT	ElsieTranslate24To32			; QDUtil.a
			IMPORT	EMT1010							; Dispatch.a
			IMPORT	Enable60HzInts					; InterruptHandlers.a
			IMPORT	EnableExtCache					; HWPriv.a
			IMPORT	EnableOneSecInts				; InterruptHandlers.a
			IMPORT	EnableSlotInts					; InterruptHandlers.a
		IF hasIopSwim THEN
			IMPORT	EnableSwimIopInts				; InterruptHandlers.a
		ENDIF
			IMPORT	EraseMyIcon						; StartSearch.a
			IMPORT	FSIODneTbl						; DeviceMgr.a
			IMPORT	GetExtHardwareInfo				; Universal.a
			IMPORT	GetHardwareInfo					; Universal.a
			IMPORT	InitADB							; ADBMgr.a
			IMPORT	InitCrsrDev						; CrsrDev.a
			IMPORT	InitCrTable						; CCrsrCore.a
			IMPORT	InitDispatcher					; Dispatch.a
			IMPORT	InitDTQueue						; DeferredTaskMgr.a
		IF hasEgret THEN
			IMPORT	InitEgretOrCuda					; EgretMgr.a
		ENDIF
			IMPORT	InitFasterInvals				; WindowMgrExtensions.a
			IMPORT	initGestalt						; GestaltFunction.a
			IMPORT	initGlobals						; SoundMgrPriv.c
			IMPORT	InitIntHandler					; InterruptHandlers.a
		IF IopADB | hasIopScc | hasIopSwim THEN
			IMPORT	InitIOPMgr						; IOPMgr.a
		ENDIF
			IMPORT	InitMemMgr						; MemoryMgr.a
			IMPORT	InitMemoryDispatch				; HWPriv.a
			IMPORT	InitMemVect						; MemoryMgr.a
			IMPORT	InitMMU							; MMUTables.a
			IMPORT	InitMMUGlobals					; MMU.a
			IMPORT	InitMMUTrap						; MMU.a
			IMPORT	InitOverPatch					; Overpatch.a
			IMPORT	InitPmgrVars					; PowerManager.a
			IMPORT	InitQueue						; Queue.a
			IMPORT	InitReliability					; SysUtil.a
			IMPORT	InitRomVectors					; VectorTableInit.a
			IMPORT	InitRSRCMgr						; ResourceMgr.a
			IMPORT	InitSCSIHW						; SCSIMgrInit.a
			IMPORT	InitSCSIMgr						; SCSIMgrInit.a
			IMPORT	InitSDTbl						; SlotInterrupts.a
			IMPORT	InitSndDispatch					; SoundDispatch.a
			IMPORT	InitSndHW						; SndPrimitives.a
			IMPORT	InitSndNoRAM					; SndPrimitives.a
			IMPORT	InitTimeMgr						; TimeMgr.a
			IMPORT	InitVBLQs						; VerticalRetraceMgr.a
			IMPORT	InitVIAs						; Universal.a
		IF has040MMU THEN							;														<SM91>
			IMPORT	InstallFPSP						; FPEmulation.a
		ENDIF										;														<SM91>
			IMPORT	InstallPrivTrap					; FPPrivTrap.a
			IMPORT	InstallSoundIntHandler			; SoundInterrupts.c
			IMPORT	JumpIntoROM						; Universal.a
		IF hasPwrControls THEN
			IMPORT	LCDScreenChk					; PowerMgr.a
		ENDIF
			IMPORT 	MARIOBOOTSOUND					; BootBeep.a
			IMPORT	MDJGNEFILTER					; ?														<SM22>
			IMPORT	MMUCleanupFor8Mb				; MMU.a
			IMPORT	NMGNEFilter						; NotificationMgr.c
			IMPORT	NMInit							; NotificationMgr.c
		IF hasPwrControls THEN
			IMPORT	PortableCheck					; PowerMgr.a
			IMPORT	PowerDownAll					; PowerMgr.a											<SM84>
		ENDIF
			IMPORT	ReadXPRam						; Clock.a
		IF hasIopScc THEN
			IMPORT	SCCIOPByPass					; IOPMgr.a
			IMPORT	SCCIOPHwInit					; IOPMgr.a
		ENDIF
			IMPORT	SCSIDiskMode					; SCSIDiskMode.a										<SM16><SM68>
			IMPORT	SetupDockBases					; DockingMgr.a
			IMPORT	StartSDeclMgr					; SlotMgrInit.a
			IMPORT	StartTest1						; USTStartup.a
			IMPORT	SysErrInit						; StartErr.a
			IMPORT	SwitchMMU						; MMU.a
			IMPORT	TEGlobalInit					; TextEditInit.a
			IMPORT	ValidatePRAM					; Clock.a

			IMPORT	INSTALLBASSCOMMON				; BassExtensions.a <SM112>
			IMPORT	FORCEINITFONTSCALL				; BassExtensions.a <SM112>

			IMPORT	GetCPUIDReg						; Universal.a
			IMPORT	InitSys7Toolbox					; StartBoot.a
			IMPORT	Ck4LimitPRAMClear				; StartSearch.a
			
		IF hasAsyncSCSI THEN
			IMPORT	ISITT
			IMPORT	INITSCSIBOOT
		ENDIF  

			IMPORT	GetRealProc						; GetReal.a


MyROM		MAIN	Export

			EXPORT	AddVidDevice
			EXPORT	BootRetry
			EXPORT	Critical
			EXPORT	DispOff
			EXPORT	InitDefGamma
			EXPORT	InitSCC
			EXPORT	OpensDrvr
;			EXPORT	PMSPSwOS
			EXPORT	RomLoc
			EXPORT	StartBoot
			EXPORT	StartInit1
;			EXPORT	WDCBSwOS
			EXPORT	TCOff
			EXPORT	SetUpTimeK						; <SM142>

;			EXPORT	DynamicBoxFlag

*************************************************************************************************
*																								*
*									S T A R T   O F   R O M										*
*																								*
*************************************************************************************************

			DC.L	numTbTrap+numOsTrap-1			; [ 0] number of traps for postlinker (HiRam stuffs checksum here)
StartPC		DC.L	ResetEntry-BaseOfRom			; [ 4] RESET vector
ROMVersion	DC.B	Machine							; [ 8] machine number
													;		NOTE: until Appletalk changes the way it checks for existence of
													;		TimeDBRA, ROM version numbers must be between $76 and $7F inclusive
			DC.B	$7D								; [ 9] Universal, Mac II class, 32 bit machines

;---------------------------------------------------
; ROM vectors & entry points
;---------------------------------------------------

StBoot		JMP 	StartBoot						; [ A] jump to start code for a restart
BadDisk		JMP 	StartBoot						; [ E] eject disk, and reboot
			DC.W	ROMRelease						; [12] ROM release version
PatchFlags	DC.B	0								; [14] ROM overpatch basis for Horror (unused in SuperMario)
			DC.B	0								;¥[15] UNUSED
			DC.L	ForeignOS-BaseOfRom				; [16] offset to foreign OS vector table
RomRsrc		DC.L	0								; [1A] ROMStart -> HiRam -> offset to ROM resource header
Eject		JMP 	GoofyDoEject 					; [1E] jump to utility to eject and notify Bruce
DispOff		DC.L	DispTable-BaseOfRom				; [22] offset to the dispatch table
Critical	JMP		CritErr							; [26] jump to critical error handler
ResetEntry	JMP 	StartBoot						; [2A] RESET entry point
RomLoc		DC.B	0								; [2E] ROM Loc (Bit 0: In Ram, Bit 1: In Emulator)
			DC.B	0								;¥[2F] UNUSED
			DC.L	0								; [30] ROM checksum byte 0
			DC.L	0								; [34] ROM checksum byte 1
			DC.L	0								; [38] ROM checksum byte 2
			DC.L	0								; [3C] ROM checksum byte 3
			DC.L	1								; [40] HiRam -> Size of ROM in bytes						<SM132>
			DC.L	EraseMyIcon-BaseOfRom			; [44] erase the happy mac
			DC.L	InitSys7Toolbox-BaseOfRom		; [48] Offset to Sys 7 Toolbox init code. (used by Boot3.a & Gibbly)
			DC.W	SubRelease						; [4C] version number of SuperMario based ROMs				<SM132>

;--- End of official ROM header --------------------


;---------------------------------------------------
;	Foreign OS table - exports offsets of interesting ROM stuff to other OS's like Aux or Pink
;---------------------------------------------------

ForeignOS	DC.L	InitDispatcher-BaseOfRom		; [4E] initializes A-trap dispatch tables
			DC.L	EMT1010-BaseOfRom				; [52] A-trap dispatcher
			DC.L	BadTrap-BaseOfRom				; [56] handler for unimplemented traps
			DC.L	StartSDeclMgr-BaseOfRom			; [5A] initializes the Slot Manager
			DC.L	InitMemVect-BaseOfRom			; [5E] initializes the Memory Manager jump tables
			DC.L	SwitchMMU-BaseOfRom				; [62] MMU switch code
			DC.L	InitRomVectors-BaseOfROM		; [66]


;---------------------------------------------------

GOOFYDoEject
			BRA.L	DoEject							; branch island to eject code


			STRING	AsIs
			DC.L	'Copyright (c) 1983-2002 Apple Computer, Inc.  All Rights Reserved.'


*************************************************************************************************
*																								*
*						R E S E T / R E B O O T   E N T R Y   P O I N T							*
*																								*
*************************************************************************************************
; b4

TCOff		dc.w	0								; for turning off MMU below

Start
StartBoot	MOVE	#$2700,SR						; Disable processor interrupts.

			RESET									; ***** Reset The World *****

; <60>, check what WakeUp does, does it return here again after changing clock ?




*************************************************************************************************
*																								*
*						H A R D W A R E   I N I T I A L I Z A T I O N							*
*																								*
*************************************************************************************************
; bc

			BSR6	JumpIntoROM						; init the hardware



			move	#$2600, sp
			moveq	#0, d7
			moveq	#0, d6
			move	#$11, d7

			import	LASTLY_A8FE0
			BSR6	LASTLY_A8FE0
			move.l	(sp),a6
StartInit1											; Jumped to from StartTest1. <C11>

;-----
;	here, after running the diagnostics, we have:
;
;		a6 ->	memory chunk table near top of highest RAM bank found by the diagnostics.
;		  		Each table entry is a pair of longwords giving the physical start address
;				and size of a RAM bank.  The table is terminated by a single longword of
;				$FFFFFFFF.  The end of the highest bank is 3 longwords after the terminator.
;
;				For instance, a two bank Mac 2 with 4 meg in bank A and 1 Meg in Bank B:
;
;					--- top of bank B ---
;						<filler 3>	- last longword of Bank B
;						<filler 2>	- next to last longword
;						<filler 1>	- next to last longword
;						$FFFFFFFF	- RAM chunk table terminator
;						$00100000	- size bank B
;						$04000000	- physical address bank B
;						$00400000	- size bank A
;					a6->$00000000	- physical address Bank A
;
;		a5 ->	top of useable memory, given RAM disk.  This is only used on contiguous
;				memory systems that support RAM disks, such as the Portable.
;
;		sp ->	a little bit (32k) above the bottom of the lowest bank of RAM found.
;
;		vbr ->	(020/30/.. only) exception vectors set up by the diagnostics at the bottom
;				of the lowest bank found.
;
;		On 68000 machines, exception vectors set up by the diagnostics are in RAM at address zero.
;-----
; de

			WITH	StartGlobals

			moveq.l	#0,d2							; no hint about configuration
getHInfo	move.l	a6,-(sp)						; save regs												<SM44>
			BSR6	GetHardwareInfo					; figure out what we are running on						<SM52>

			movem.l	d0-d1/d7,-(sp)					; save universal regs									<SM44>	
			BSR6	GetExtHardwareInfo				; Get extended universal information
				
			move.l	12(sp),a6						; get pointer to bootglobs
			movem.l	d0-d1/d3-d4,sgScratch(a6)		; save extended info in scratch space in BootGlobs
			movem.l	(sp)+,d0-d1/d7					; restore valid and ext feature flags #0-31

;-----
;	Here, after running GetHardwareInfo we have:
;
;  		a0 - Pointer to table of base addresses
;		a1 - Pointer to ProductInfo record for this machine
;		d0 - Flags indicating which base addresses are valid
;		d1 - Flags indicating which external features are valid
;		d2 - Bits 31..16, hwCfgFlags info (possibly unknown)
;		d2 - Bits 15..8, BoxFlag info (possibly unknown)
;		d2 - Bits  7..0, Address Decoder Kind (zero if unknown)
;-----
; 108

			BSR6	InitVIAs,a2						; initialize the VIAs and RBV

			BSR.L	ValidatePRAM					; make sure PRAM is checked for reasonable values

			move.l	(sp)+,a6						; restore regs											<SM44>

;----------------------------------------------------------------
; Get logical: set up RAM, address translation tables
;----------------------------------------------------------------
; 11a

			bsr		ConfigureRam					; set up RAM, move sp to middle of 1st bank

;----------------------------------------------------------------
; D7 <- CPU type in low word, logic board type in hi word
;----------------------------------------------------------------
; 11e
			BSR		WhichCPU						; get CPU type in low word of d7
			bsr		WhichBoard						; get logic board type in hi word of d7

			bsr.l	InitMMU							; generate MMU tables, enable MMU						<SM15>
													; returns a4 -> BootGlobs
			
			move.l	sgTotalRAM(a4),a6				; get top of memory
			move.l	a4,a5							; get ptr to BootGlobs
			add.l	sgAllocOff(a4),a5				; top useable memory = ptr + allocation offset
@done
	

;-----
; Now that we have low memory, set up some globals.  We may nuke some of them later if its
; a cold boot, but we will re-set them up.
;
;	At this point:
;		'Universal ROM' registers
;  			a0 - Pointer to table of base addresses in physical space
;			a1 - Pointer to ProductInfo record for this machine in physical space
;			d0 - Flags indicating which base addresses are valid
;			d1 - Flags indicating which external features are valid
;			d2 - Bits 15..8, BoxFlag info (possibly unknown)
;			d2 - Bits  7..0, Address Decoder Kind (zero if unknown)
;			d7 - bits 31-16: logic board type
;			d7 - bits 15-0: cpu type (0 = 68000, 1 = 68010, etc)
;
;		a4  - points to BootGlobs in logical space
;		a5	- top of useable memory
;		a6	- top of memory
;		sp	- in the middle of the useable logical space
;
;-----
; 136

			MOVEM.L	sgScratch(A4),D3-D6				; get the extended Universal info						<SM82>
			ENDWITH									; {StartGlobals}

			MOVEM.L	D0-D6/A0-A1,-(SP)				; save all Universal info								<SM82>

		IF forRomulator THEN						;														<T5>
			TestInRam	a0							; are we in RAM?
			beq.s	@notInRam						; IF we are in RAM THEN
			LEA		$300,A0							;	use $300 so we don't blow away nub vars
			bra.s	@cont							; 	continue
@notInRam											;
		ENDIF										; ELSE
			LEA		SysCom,A0						; 	A0 <- pointer to start of system globals
@cont												; ENDIF
			LEA		HeapStart,A1					; A1 <- pointer to end of system globals.
			BSR		FillWithOnes					; Fill system globals with ones.

			BSR.L	InitRomVectors					; initialize ROM vectorization

			MOVEM.L	(SP)+,D0-D6/A0-A1				; restore Universal info								<SM82>

			swap	d2								; get high word for flags
			move.w	d2,HwCfgFlags					; store in the low mem global
			swap	d2								; restore d2 to original value

			move.l	d0,AddrMapFlags					; save Universal info
			move.l	d1,UnivROMFlags					;
			move.l	a1,UnivInfoPtr					;
			move.l	d3,AddrMapFlags1				;  and extended universal info
			move.l	d4,UnivROMFlags1				;
			move.l	d5,AddrMapFlags2				;
			move.l	d6,UnivROMFlags2				;

			MOVE.B	D7,CpuFlag						; save type of CPU we have
			swap	d7								;
			
@StoreBox	move.b	d7,BoxFlag						; ... and save it in lomem

			move.l	a4,BootGlobPtr					; save the pointer to the boot globals (near top of RAM)
			MOVE.L	A5,BufPtr						; save the top of useable memory
			MOVE.L	A6,MemTop						;  and the top of available memory

			move.l	UnivInfoPtr,a1					; reload a1 in case the info record was adjusted in RAM	<SM108> rb
			
			bsr		SetupHWBases					; setup the hardware base address low mems

			BSR		InitSCC							; init the SCC

			bsr.l	InitMMUGlobals					; set up MMU globals

			BSR6	 SysErrInit						; Init exception vectors.
			clr.l	DockingGlobals					; flag for EnableExtCache to know traps don't exist	<H15>
			
			MOVE.L	#(1<<CACR_EI_020_030|\			; WA=1, DBE=1, CD=1, ED=1, IBE=1, CI=1, EI=1
					  1<<CACR_CI_020_030|\			;
					  1<<CACR_IBE_030|\				;
					  1<<CACR_ED_030|\				;
					  1<<CACR_CD_030|\				;
					  1<<CACR_DBE_030|\				;
					  1<<CACR_WA_030),D0			;
@EEC												; nothing to do with Europe or Eric Clapton
			Movec	D0,CACR							; set up the CACR as desired from above
			BSR.L	EnableExtCache					; enable external cache

			BSR.L	DisableIntSources				; mask all interrupts
			BSR		SetUpTimeK						; Initialize TimeDBRA and TimeSCCDB.

			BSR		InitHiMemGlobals				; set up high memory.  If > 8 meg RAM and 24-bit OS,
													; BufPtr clipped at 8 meg and stack at 4 meg


*************************************************************************************************
*																								*
*										B O O T   R E T R Y										*
*																								*
*	Come back here if we fail to mount a volume, get a System file, or get memory.				*
*																								*
*	The only variables we don't reset at this time are:											*
*																								*
*		BootMask - needed to avoid continually trying to boot off a hard disk with bad blocks	*
*		MemTop, PWMBuf1, PWMBuf2, PWMValue, SoundBase, BufPtr									*
*		CPUFlag, TimeDBRA, TimeSCCDB, TimeSCSIDB												*
*		all Universal variables (i.e., UnivInfoPtr, UnivROMFlags, AddrMapFlags, etc)			*
*																								*
*************************************************************************************************
; 1ce

BootRetry	MOVE	#$2700,SR						; disable interrupts

;	initialize enough to get the Memory Manager going for InitIntHandler

			BSR		InitGlobalVars					; initialize a bunch of global variables
			BSR.L	DisableIntSources				; mask all interrupts

			BSR.L	InitDispatcher					; initialize the trap dispatcher
			BSR.L	InitMMUTrap						; set up SwapMMUMode trap
			BSR.L	InitMemMgr						; initialize the memory manager
			BSR		SetUpSysAppZone					; setup the system/application heap zone

; 	Move Stack to halfway through RAM and set new system heap limit.

			BSR		CompBootStack					; A0 <- the location of the stack at boot time
			MOVE.L	A0,SP							; Set the stack pointer there
			SUBA.W	#BootStackSize,A0				; Give ourselves some stack space

			_SetApplLimit							; Don't let the System Heap crash our stack

			BSR.L	InitMemoryDispatch				; go set up the MemoryDispatch globals

;	initialize the expanded low-mem area (really in the system heap)

			WITH	ExpandMemRec					;														<SM40>
			Move.l	#emRecSize,d0					; size of ext to old low-mem							<SM40>
			_NewPtr	sys,clear						; get a blob											<SM40>
			Move.l	a0,ExpandMem					; stuff global ptr										<SM40>
			Move.w	#emCurVersion,(a0)+				; version number										<SM40>
			Move.l	#emRecSize,(a0)					; size													<SM40>
			ENDWITH									;														<SM40>

			IMPORT	InterC_1cc0_MoveUnivInfoToSysHeap
			BSR.L	InterC_1cc0_MoveUnivInfoToSysHeap
			BSR.L	initGestalt						; initialize Gestalt									<SM39>
			BSR.L	CreateAltiVecBufForEmulator
			BSR.L	InitIntHandler					; initialize interrupt vectors and dispatch tables

			BSR		CheckForEgretOrCuda				; Do we have an Egret/Caboose/Cuda?						<mc2>
			BNE.S	@EInitDone						; -> Nope, don't be callin' shit
			BSR.L	InitEgretOrCuda					; Initialize Egret or Cuda Manager

			IMPORT	GestaltCudaFunc
			BSR.L	GestaltCudaFunc
@EInitDone


*************************************************************************************************
*																								*
*							W E L C O M E   T O   M A C I N T O S H								*
*																								*
*	At this point, all the machine/feature specific stuff should be setup, so we should be		*
*	able to take off as if we were a generic Macintosh.											*
*																								*
*************************************************************************************************
; 244

			BSR.L	InitRSRCMgr						; initialize the Resource Manager
			BSR.L	NMInit							; Initialize the Notification Manager
		
			CLR.W	-(SP)							; pass the INIT message to ShutDown
			_ShutDown								;  to initialize the queue

			IMPORT	EXPANSIONBUSMGR_452D0
			BSR.L	EXPANSIONBUSMGR_452D0

;ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ	<SM101> SAM
; Install Code Fragment Mangaer (GoNative)								<tcn>
;ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ
; 25a

		CASE	ON
		IMPORT 	GoNative
			BSR.L	GoNative						; Load all those NCODs!
		CASE	OFF
			BPL.S	@noPower						; -> No errors.  Keep booting							<SM132> SAM
			
			MOVE.W	#dsGNLoadFail,D0				; Fatal GoNative load error.							
			_SysError								; Put up a dialog and die.
@noPower

; 268
			IMPORT	InterC_1690_CodeRegister
			BSR.L	InterC_1690_CodeRegister

			IMPORT	InterC_15c0_CodePrepare2
			BSR.L	InterC_15c0_CodePrepare2

			IMPORT	EXPANSIONBUSMGRFIRSTFUNC
			BSR.L	EXPANSIONBUSMGRFIRSTFUNC

			BSR.L	CompBootStackOld				; lifted from SetUpSysAppZone
			MOVE.L	A0,SP
			SUBA.W	#BootStackSize,A0
			_SetApplLimit

			IMPORT	InterC_2560
			BSR		InterC_2560


			CLR.L	-(SP)							; who wrote this?
			MOVE.L	(SP)+, ($D18)
			MOVE.L	ToolScratch, -(SP)
			LEA.L	SetUpTimeK, A0
			MOVE.L	A0, ToolScratch

			IMPORT	InterC_2090_PowerMgr
			BSR		InterC_2090_PowerMgr

			IMPORT	InterC_2a80_EtherPrintfLib
			BSR.L	InterC_2a80_EtherPrintfLib
			MOVE.L	(SP)+, ToolScratch


			BSR		GetPRAM							; get 20 bytes PRAM, and TIME

			BSR		InitSlots						; inits slot cards, grays the screen(s)

			BSR.L	InitDTQueue						; initialize the Deferred Task Manager Queue

			BSR.L	EnableOneSecInts				; allow the clock interrupts
			BSR.L	Enable60HzInts					; allow vbl interrupts

;----------------------------------------------------------------
; Enable processor interrupts, after which we can start wanging real hw
;----------------------------------------------------------------

			MOVE	#$2000,SR						; supervisor state, interrupts on

			IMPORT RSETKMAP
			BSR.L     RSETKMAP

			IMPORT	InterC_2bc0_DebugPrint
			BSR.L	InterC_2bc0_DebugPrint

			MOVEQ.L	#10, D0
			_NewHandle ,Sys,Immed
			MOVE.L	A0, D0
			BEQ.B	@fail
			MOVE.L	D0, $1E0C
@fail

			BSR.L	INSTALLBASSCOMMON				; Init Bass before anyone calls _InitFonts (like _InitGraf) <SM112>
			BSR.L	FORCEINITFONTSCALL				; More Bass init stuff										<SM112>

			BSR		InitCrsrMgrMiddle
			BSR.L	InitCrsrDev						; initialize Cursor globals								<H9>
													; (InitCrsrDev must preceed InitADB)

			SUBQ	#2, SP
			MOVEQ.L	#-1, D0
			_DisplayDispatch
			ADDQ	#2, SP

;----------------------------------------------------------------
; Install Drivers (Disk, Sound, Video).
;----------------------------------------------------------------
; 300

			LEA		DrvQHdr, A1						; Initialize the drive queue.
			BSR.L	InitQueue

			BSR		InitDeviceMgr					; Init unit I/O table and install the drivers.

			IMPORT	InitDeviceDispatch
			BSR.L	InitDeviceDispatch

			BTST.B	#$6, ($2400)
			BNE.B	@definitely
			BTst.B	#$0, ($DD0)
			BEQ.B	@dont
@definitely

			BSR		SetScsiIdFromPram				; taken from SCSIMgrInit.a
			BSR.L	InitSCSIMgr						; Init old and new SCSI Mgrs
@dont

			IMPORT	InitExpansionMgr
			BSR.L	InitExpansionMgr

			IMPORT	InterC_1980_Drivers
			BSR.L	InterC_1980_Drivers

			BSR		LoadDrivers						; load the standard drivers

			BSR.L	InitADB							; initialize ADB interface

	import	InterC_1910_USBFamilyExpertLib
	bsr.l	InterC_1910_USBFamilyExpertLib

			BSR		InitCrsrMgr						; Initialize cursor variables

			IMPORT	InitBCScreen
			BSR.L	InitBCScreen

			BSR.L	TEGlobalInit					; initialize TextEdit vectors

;----------------------------------------------------------------
; Create a temporary application heap.  Load boot block buffer
; ptr into A6 and phoney A5 global world.  Note these are based
; on an SP pointing to an EMPTY stack, whose location was earlier
; computed to be at (MemTop/2 - BootGlobalsSize).
;
; Historically, there was a _SetAppBase here after the system zone had been grown during
; initialization so far.  We continue with the coincident zones, but run the _SetAppBase anyway
; for the sake of its internal side-effects.  After the call, ApplZone, HeapEnd, and HiHeapMark
; must be reset.  ApplLimit is set to BufPtr-DefltStack, which is fine for boot time.
;----------------------------------------------------------------
; 35a

			MOVE.L	SysZone,A0						; Point to System Heap
			MOVE.L	bkLim(A0),A0					; Point to end of System Heap
			ADDA.L	#MinSysExtra,A0					; Make sure we have enough System Heap space
			_SetAppBase								; Set up the start of the application heap
			MOVEA.L	SysZone,A0						; the one true zone
			MOVE.L	A0,TheZone						; We still want the System Heap to be the default
			MOVE.L	A0,ApplZone						; revert to coincident zones
			MOVE.L	bkLim(A0),HeapEnd				; end of dynamic sys/appl zone
			LEA		BootGlobalsSize(SP), A6			; boot blocks load pt
			LEA 	QDBootGlobalsSize(SP),A5		; leaving room for globals

			BSR.L	EnableSlotInts					; enable NuBus slot interrupts

			BSR.L	InitFasterInvals				; init the expandmem variable for WindowMgr

		IF hasPwrControls THEN
			BSR.L	PowerDownAll					; power down all peripheral subsystems
		ENDIF
	
			BSR		DrawBeepScreen					; Horst Beepmanh's patented gray screen
			
			MOVE.L	#WmStConst,WarmStart			; write warm start constant to indicate warm start

			MOVEA.L	BootGlobPtr,A0							; point to bootGlobals
			move.l	#WmStConst,StartGlobals.sgWarmStart(A0)	; flag warm start in a
															; place where StarTest can see it w/o an MMU




			import	InterC_2780_FireWire
			bsr.l	InterC_2780_FireWire


;----------------------------------------------------------------
; Initialize the File System.
;----------------------------------------------------------------
; 3b0

			MOVE	#40,D0							; Inital number of file control blocks
			_InitFS

;----------------------------------------------------------------
; <65>, Other Terror changes...
;----------------------------------------------------------------
; 3b6

			BTST	#$1, $2409
			BEQ.B	@dont_do_mysterious_thing
			IMPORT	LoadPCCardLib
			BSR.L	LoadPCCardLib
@dont_do_mysterious_thing

	IMPORT	InterC_2a20_SCSITargetMode
	BSR.L	InterC_2a20_SCSITargetMode

	BTst.B	#5, $2408
	BEQ.B	@nodiskmode
			BSR.L	SCSIDiskMode					; check if we should be in SCSI Disk Mode				<SM16>
@nodiskmode

			BSR.L	INITSCSIBOOT					; allocate some memory for SCSI booting
													; and load third party SIMs (SCSI Interface
													; modules

			IMPORT	ATAMgr_5dae0
			BSR.L	ATAMgr_5dae0
			IMPORT	ATAMgr_5dde0
			BSR.L	ATAMgr_5dde0

			IMPORT	InterC_2130_CardBus
			BSR		InterC_2130_CardBus


*************************************************************************************************
*																								*
*				Everything's ready to go, so go look for a disk to boot from					*
*																								*
*************************************************************************************************

			BRA		BootMe								; Exit Stage Right



*************************************************************************************************
*																								*
*						M I S C E L L A N E O U S   U T I L I T I E S							*
*																								*
*************************************************************************************************


;________________________________________________________________________________________
;
; Routine:	WhichCPU 3f2
;
; Inputs:	none
;
; Outputs:	D7.L-	0, 1, 2, 3, or 4 for 68000, 68010, 68020, 68030, 68040 respectively
;
;			020 - icache flushed & enabled
;			030 - both caches flushed, icache enabled, dcache set up for write allocate
;			      but not enabled
;			040 - both caches invalidated, icache enabled.
;
; Trashes:	none
;
; Function:	determines which sibling of the 68K is running by looking at exception stack
;			frames, addressing modes, and at instruction/data cache enables
;
; Technical details:
;
;	020 CACR:		(from MC68020 User's Manual, 3rd Ed.  pg. 6-3)
;			+------------------------------------------------+
;			|  0  ..............  0 |  C  |  CE  |  F  |  E  |
;			+------------------------------------------------+
;			  31                  4    3      2     1     0
;
;				C   =  Clear Cache
;				CE  =  Clear Entry
;				F   =  Freeze Cache
;				E   =  Enable (Inst.) Cache
;
;
;	030 CACR:		(from MC68030 User's Manual, 2nd Ed.  pg 6-15)
;			+------------------------------------------------------------------------------------+
;			|  0  ...  0  | WA | DBE | CD | CED | FD | ED | 0 | 0 | 0 | IBE | CI | CEI | FI | EI |
;			+------------------------------------------------------------------------------------+
;			 31       14    13    12   11    10    9    8   7   6   5    4    3     2    1     0
;
;				WA  =	Write Allocate
;				DBE =	Data Burst Allocate
;				CD	=	Clear Data Cache
;				CED	=	Clear Entry in Data Cache
;				FD	=	Freeze Data Cache
;				ED	=	Enable Data Cache
;				IBE	=	Instruction Burst Enable
;				CI	=	Clear Instruction Cache
;				CEI	=	Clear Entry in Instruction Cache
;				FI	=	Freeze Instruction Cache
;				EI	=	Enable Instruction Cache
;
;
;	040 CACR:		(from MC68040 User's Manual, 1st Ed.,  pg. 7-19)
;			+-------------------------------------+
;			|  DE  |  0 ... 0  |  IE  |  0 ... 0  |
;			+-------------------------------------+
;			   31    30     16    15    14     0
;
;				DE	=	Enable Data Cache
;				IE	=	Enable Instruction Cache
;
;
;			The assumption made here (and other places where the CACR is manipulated) are
;			that if the bits specified in the CACRs above specified as having a value of
;			zero are written, those bits are ignored. All bits documented in the CACR as
;			zero are ALWAYS read as zeroes.  Given the placement of the various bits,
;			setting a bit that is valid in one of the MC68xxx processors that is undefined
;			(reserved, or zero) on others will be the method of CPU detection.
;________________________________________________________________________________________

WhichCPU
			MACHINE	MC68020

			moveq.l	#2,d7							; setup index to see if index scaling works
			rts										; all done


;________________________________________________________________________________________
;
; Routine:	WhichBoard 3f6
;
; Inputs:	D7.B-	CPU type
;
; Outputs:	D7.L-	[ 0 ] [logic board type, i.e., boxFlag] [ 0 ] [CPU type]
;
; Trashes:	none
;
; Function:	figures out what logic board we are running on
;________________________________________________________________________________________

WhichBoard	swap	d7								; get CPU type in hi word
			clr.w	d7								; be defensive, prepare a word...
			move.b	ProductInfo.ProductKind(a1),d7	; get the BoxFlag value
			swap	d7								; put BoxFlag into hi word
			rts


;________________________________________________________________________________________
;
; Routine:	SetUpTimeK 402
;
; Inputs:	D7.B-	CPU type
;
; Outputs:	D7.L-	[ 0 ] [logic board type, i.e., boxFlag] [ 0 ] [CPU type]
;
; Trashes:	D0-D2, A0-A4
;
; Function:	sets up timing constants in low memory:
;
;			TimeDBRA	-	empty DBRA iterations/millisecond
;			TimeSCCDB	-	TST SCC + DBRA iterations/millisecond (used by AppleTalk)
;			TimeSCSIDB	-	TST SCSI 5380 + DBRA iterations/millisecond (used by SCSI Manager)
;
;			NOTE: VIA1 Timer 2 must not be in use, and there must be no sources of
;				  processor interrupts (although processor interrupts will be enabled)
;________________________________________________________________________________________

SetUpTimeK	
		   MoveM.L   D1-D2/A1-A4, -(A7)
		   Move      SR, -(A7)
		   OrI       #$700, SR
		   Move.L    ($64), -(A7)
		   BTst.B    #$6, ($2400)
		   BNE.B     L8
		   BTst.B    #$1, ($2400)
		   BNE       L12
		   Bra       L13
L8:        MoveQ.L   #$0, D0
		   Move      ([$68FFEFD0.L],$80), D0

		   MoveM.L   D0-D2/A0, -(A7)
		   MoveA.L   ([$68FFEFD0.L],$18), A0

		   Tst.L     A0
		   BNE.B     L10
		   MoveA.L   ([$68FFEFF0.L],$100), A0

		   Move.L    #$80000000, D1
		   CmpI.L    #$1F, D0
		   BGT.B     L9
		   ROR.L     D0, D1
		   Or.L      D1, $14(A0)
		   Nop
		   Bra       L11
L9:        SubI.L    #$20, D0
		   ROR.L     D0, D1
		   Or.L      D1, $4(A0)
		   Nop
		   Bra       L11
L10:       AddA.L    #$10000, A0
		   LsL.L     #$5, D0
		   Move.L    $0(A0,D0.W), D1
		   BClr.L    #$7, D1
		   Move.L    D1, $0(A0,D0.W)
		   Nop
L11:       MoveM.L   (A7)+, D0-D2/A0
		   Bra.B     L13
L12:       MoveA.L   ($DD8), A0
		   AddA.L    (A0), A0
		   MoveA.L   $E4(A0), A0
		   OrI.L     #$400, $24(A0)

L13:       MoveA.L   ($1D4), A1
		   BClr.B    #$5, $1600(A1)
		   Nop
		   Move.B    #$FF, $1200(A1)
		   Nop
		   Move.B    #$A0, $1C00(A1)
		   Nop

;	Load timer with number of VIA ticks per millisecond - 3.  There are 3 clocks of overhead
;	because it takes 1 clock for the timer to load, and 2 extra clocks because it has to count
;	through -1, instead of down to 0.

			moveq.l	#(NTicks-3)**$FF,d1				; low byte of value to load into timer
			moveq.l	#(NTicks-3)>>8,d2				; high byte of value to load into timer

			movea.l	sp,a3							; mark the stack
			lea		TimerInt,a0						; point to the interrupt handler
			move.l	a0,AutoInt1						; setup the interrupt handler
			lea		TimingTable,a4					; point to table of routines to time

@nextRoutine
			movea.l	a4,a0							; point to table entry
			adda.w	(a4),a0							; get routine address
			moveq.l	#2,d0							; make a quick run to get it into the cache
			lea		@cacheLoaded,a2					; setup return address
			jmp		(a0)							; call the routine to time
@cacheLoaded
			movea.l	a4,a0							; point to table entry
			adda.w	(a4)+,a0						; get routine address
			moveq.l	#-1,d0							; run until the timer interrupts
			lea		@timedOut,a2					; setup return address
			andi.w	#$F8FF,sr						; enable interrupts
			jmp		(a0)							; call the routine to time
@timedOut	not.w	d0								; convert to number of loop executions.

			bne.s	@skip_the_thing
			move.w	#$ffff, d0
@skip_the_thing

			movea.w	(a4)+,a0						; get the address of the lowmem
			move.w	d0,(a0)							; store the result

			btst	#6,$2400          
			beq.b	@dont
			MOVE.B   ([$68FFEFD0],$0083),([$68FFEFD0],$008D) ; VIAIntBit+1 -> CompletedInts+1
@dont

			tst.w	(a4)							; see if any more routines to time
			bne.s	@nextRoutine					; time all routines in the table
		eieioSTP
			move.b	#(0<<ifIRQ)+(1<<ifT2),vIER(a1)	; Disable Timer 2 interrupts.
			NOP
			MOVE.L   (A7)+,$0064
			MOVE     (A7)+,SR
			MOVEM.L  (A7)+,D1/D2/A1-A4 
			rts

TimerInt	nop
			tst.b	vT2C(a1)						; Reset the timer interrupt.
			nop
			movea.l	a3,sp							; restore the stack pointer
			jmp		(a2)							; just jump to the return address

TimingTable	dc.w	DbraTime-*,TimeDBRA				; simple DBRA loop timing
			dc.w	SCCTime-*,TimeSCCDB				; SCC access timing
			dc.w	SCSITime-*,TimeSCSIDB			; SCSI access timing
			dc.w	VIATime-*,TimeVIADB				; VIA access timing
			dc.w	0								; end of list


DbraTime	
			move.b	d1,vT2C(A1)						; load low order byte
			move.b	d2,vT2CH(A1)					; load high order byte & go.
@loop		
			dbra	d0,@loop						; time an empty DBRA loop
			jmp		(a2)							; return if loop expires


SCCTime		
			movea.l	SCCRd,a0						; point to SCC base read address
			move.b	d1,vT2C(A1)						; load low order byte
			move.b	d2,vT2CH(A1)					; load high order byte & go.
@loop		
			btst.b	#3,$DD3
			bne.s	@differentloop
			dbra	d0,*							; time the SCC DBRA loop
			jmp		(a2)							; return if loop expires
@differentloop
			btst.b	#0,(a0)
			dbra	d0,@differentloop
			jmp		(a2)


SCSITime	
			TestFor	SCSI96_1Exists
			bne.s	@normalTest

			btst.b	#6, $2400
			beq.s	@normalTest

			move.b	d1, vT2C(a1)					; load low order byte
			move.b	d2, vT2CH(a1)					; load high order byte & go.
			dbra	d0, *
			jmp		(a2)

@normalTest
			movea.l	SCSIBase,a0						; point to SCSI base address
			move.b	d1, vT2C(a1)					; load low order byte
		eieioSTP
			move.b	d2, vT2CH(a1)					; load high order byte & go.
		eieioSTP
			TestFor	SCSI96_1Exists					; use macro to check if we have
			beq.s	@loop80							;   SCSI96. Bra. if not
@loop96		
			btst.b	#0, rSTA(a0)					; typical SCSIMgr96 loop
			dbra	d0, @loop96						; time the SCSI DBRA loop
			jmp		(a2)							; return if loop expires

@loop80		
			btst.b	#0,sCSR(A0)						; typical SCSIMgr loop
			dbra	d0,@loop80						; time the SCSI DBRA loop
			jmp		(a2)							; return if loop expires


; ----------------------------------------------------------------------------------------------------- 	<H11>
;
;	VIATime 5ca, in the IIci/IIfx/TERROR/HORROR ROMs, lives at 40x008BC.										<H11>
;														 --------
;	This means that the @loop    btst.b  #0,(A0)    is at 40x008C8, and the    dbra   d0,@loop				<H11>
;	is at 40x008CC.  This code, "half cache-line aligned, when run on an 040 and above, will execute		<H11>
;	in an on-chip cache SEPARATE FROM THE I-CACHE, called (appropriately), the DBRA-CACHE (not to be		<H11>
;	confused with the Zebra-cache, or any other African equine).  Why this is so important is that the		<H11>
;	memory address the BTST.B is referencing is a VIA (not surprising, since this is a loop that			<H11>
;	calculates Time-VIA-DB), and on 040s and above I/O space ($5xxxxxxx) is marked as non-cached and		<H11>
;	serialized.  At 20MHz and below, 040s will encounter a 'beat frequency' between the CPU and VIA			<H11>
;	clocks, which will cause the CPU to miss both edges of the VIA clock on the first pass.  This causes	<H11>
;	the CPU to have to wait an extra VIA clock cycle (1.2µs * 2 = 2.4µs) to access the register on the		<H11>
;	VIA about 21% of the time when running out of the DBRA CACHE.  However, if the loop is unaligned and	<H11>
;	does not run from the DBRA-cache and CPU = 040 @ ² 20MHz, it will synchronize with the VIA clock		<H11>
;	on the first VIA clock cycle ZERO percent of the time.  So, just to perform sadistic, saddalistic		<H11>
;	necroequinia, ALL unaligned loop VIA accesses at 20MHz and below will take 2.4µs.  This is important	<H11>
;	(you knew I'd get to this part eventually, right?) when using TimeVIADB as an EXACT time instead of		<H11>
;	a "minimum" type of timing constant.  Poignant example - {Drivers}Sony:SonyMFM.a in mWrData uses		<H11>
;	TimeVIADB to wait EXACTLY a certain amount of time (~ 235µs).  However, the constant generated from		<H11>
;	this loop when it is aligned is $2B0.  But 1ms/$2B0 ~= 1.45µs, which indicates the bias of 79% of the	<H11>
;	VIA accesses taking 1.2µs (1.2µs * (0.79 * $2B0) = 652µs) and 21% taking 2.4µs							<H11>
;	(2.4µs * (0.21 * $2B0) = 346µs), giving (652+346 = 998µs.  The loop in mWrData is unaligned so 100%		<H11>
;	of the VIA accesses will take 2.4µs.  So instead of the loop waiting 235µs (040 @ 20MHz = 162 times		<H11>
;	thru the loop; 162 * 1.45 = ~235), it actually waits 162 * 2.4 = ~389 µs.  This is bad since the		<H11>
;	reason why this loop is waiting is for the floppy drive head to reach the correct place at the start	<H11>
;	of a sector to begin writing and since that loop waits so long, sectors are written late and the		<H11>
;	floppy is trashed.																						<H11>
;
;	So by unaligning this loop it calculates a smaller number since each VIA access will then take 2.4µs	<H11>
;	and mWrData will work correctly.
;
;	In the case of 25MHz and above 040 processors, the rate that CPU and VIA clocks don't synchronize		<H11>
;	drops to ~ 1% and above that the CPU clock rate is fast enough that it always guarantees that it		<H11>
;	NEVER misses the first synchronization with the VIA clock.  Unaligning the loop has no effect on		<H11>
;	³ 25MHz 040 processors.																					<H11>
;
; ----------------------------------------------------------------------------------------------------- 	<H11>

VIATime		
			lea		vIER(a1),a0						; <40x008BC> point to a VIA register					<H11>
		eieioSTP
			move.b	d1,vT2C(A1)						; <40x008C0> load low order byte						<H11>
		eieioSTP
			move.b	d2,vT2CH(A1)					; <40x008C4> load high order byte & go.					<H11>
		eieioSTP
@loop		
			btst.b	#0,(A0)							; <40x008CA> typical VIA access loop					<H11>
			dbra	d0,@loop						; <40x008CE> time the VIA DBRA loop						<H11>
			jmp		(a2)							; <40x008D2> return if loop expires						<H11>


;________________________________________________________________________________________
;
; Routine:	JmpTblInit 5e0, JmpTbl2 5e2
;
; Inputs:	A0	-	pointer to table of routine word offsets (A0-relative)
;			A1	-	pointer to destination jump table in RAM
;			D1	-	number of vectors to install - 1
;
; Outputs:	A0	-	pointer to next entry in offset table
;			A1	-	pointer to next jump table entry in RAM
;
; Trashes:	D0-D2
;
; Function:	sets up RAM-based jump tables from ROM-routine offset tables
;________________________________________________________________________________________

JmpTblInit	MOVE.L	A0,D0							; remember its address
JmpTbl2		MOVEQ	#0,D2							; clear high part for arithmetic
			MOVE.W	(A0)+,D2						; get the next offset
			ADD.L	D0,D2							; compute the address
			MOVE.L	D2,(A1)+						; install it in the jump table
			DBRA	D1,JmpTbl2						; loop for all vectors
			RTS


;________________________________________________________________________________________
;
; Routine:	FillWithOnes 5f0
;
; Inputs:	A0	-	pointer to starting RAM location (must be longword aligned)
;			A1	-	pointer to ending RAM location (must be longword aligned)
;
; Outputs:	A0	-	pointer to next entry in offset table
;			A1	-	pointer to next jump table entry in RAM
;
; Trashes:	D0-D2
;
; Function:	fills a longword-aligned memory range with all 1's
;________________________________________________________________________________________

FillWithOnes
			MOVEQ	#-1,D1							; what to fill memory with								<SM84>
@FillLoop	MOVE.L	D1,(A0)+						; fill next longword									<SM84>
			CMPA.L	A1,A0							; have we reached the end of the range?					<SM84>
			BLO.S	@FillLoop						; -> no, keep looping until done						<SM84>
			RTS										;														<SM84>


;________________________________________________________________________________________
;
; Routine:	CompBootStack 5fa
;
; Inputs:	none
;
; Outputs:	A0	-	location of stack pointer at boot time
;
; Trashes:	D0
;
; Function:	computes the boot time stack pointer = sysZone + (BufPtr-sysZone)/2 - space for QD
;________________________________________________________________________________________

CompBootStack
			btst	#$06,$240B
			beq.s	CompBootStackOld
			move.l	#$007EFFE0,A0					; 8 M - 64 K - 32 b
			rts

CompBootStackOld
			move.l	BufPtr,d0						; get top useable memory
			move.l	sysZone,a0						; get start system heap
			sub.l	a0,d0							; get (top useable - sys heap start)
			lsr.l	#1,d0							; divide by two
			add.l	a0,d0							; get sys heap + (top - sysHeap)/2
			sub.w	#BootGlobalsSize,d0				; leave room for QuickDraw stuff.
			andi.w	#$FFF0,d0						; force it to be even									<SM81>
			move.l	d0,a0
			rts


;________________________________________________________________________________________
;
; Routine:	ConfigureRAM 624
;
; Inputs:	D2.B-	address decoder kind (from Universal)
;			A0	-	pointer to machine's DecoderInfo table (from Universal)
;			A6	-	pointer to RAM chunk table
;
; Outputs:	A6	-	pointer to RAM chunk table
;						RAM chunk table pointed to by A6 reflects current RAM h/w setup
;						'offset to top of bank' field in boot globals is set up
;			SP	-	initialized to value as described below
;			Universal ROM registers (A0-A1/D0-D6) unchanged
;
; Trashes:	D7, A2-A5
;
; Function:	sets up the stack to point at 1.5 meg into the first bank if it's ³2 meg,
;			otherwise it points at 3/4 of the first bank's size.  It also changes the
;			chunk table so there is one entry per contiguous block of physical RAM. (ie
;			it merges two or more adjacent physical entries into one with a size equal to
;			the sum of the adjacent chunks).
;________________________________________________________________________________________

ConfigureRAM
			WITH	StartGlobals					;														<SM45>

			move.l	(sp)+,sp						; save return address
			move.l	4(a6),d7						; get size 1st chunk
			cmp.l	#$200000,d7						; at least two meg of RAM in first bank?				<T16>
			bhs.s	@plentyORam						; IF we have less than two meg THEN						<T16>
			lsr.l	#2,d7							;   divide amt useable logical memory by 4				<T16><SM116>
			mulu.l	#3,d7							;	multiply by 3 to get 3/4 of useable memory			<T16><T32>
			bra.s	@stakOk							;	go set stack										<T16>
@plentyORam											; ELSE													<T16>
			move.l	#defStackAddr,d7				;	use default stack addr 								<T16>
@stakOk												; ENDIF
			exg.l	d7,sp							; set stack at increment
			add.l	(a6),sp							; add in base 1st chunk
			move.l	d7,-(sp)						; restore return address
		
			move.l	a6,a3							; ptr into chunk table
@newBank	move.l	a3,a2							; keep ptr to bank size
			move.l	(a3)+,d7						; init size
@loop		add.l	(a3)+,d7						; add in length
			cmp.l	(a3)+,d7						; does next start = start of next bank?
			beq.s	@loop							; yes, continue merging

			sub.l	(a2)+,d7						; subtract off start to get size
			move.l	d7,(a2)+						; write back the total
			subq.l	#4,a3							; no, back up to start of that bank

			cmpi.l	#-1,(a3)						; any more banks?
			bne.s	@newBank						; and start merging again with that bank...

			move.l	(a3)+,(a2)+						; write the terminator									<SM116>		
			move.l	(a3)+,(a2)+						; copy the 1st dig long			
			move.l	(a3)+,(a2)+						; copy the 2nd dig long				
			move.l	(a3)+,(a2)+						; copy the 3rd dig long				
;			move.l	(a3)+,(a2)+						; copy the last diag sig long		

			sub.l	a6,d7
			move.l	d7,sgTopOff(a6)					; save offset to top of RAM
			rts										;
			
			ENDWITH									; {StartGlobals}


;________________________________________________________________________________________
;
; Routine:	SetUpSysAppZone 674
;
; Inputs:	none
; Outputs:	none
; Trashes:	D0,A0
;
; Function:	Creates the system heap we'll use till rebooting.  It's handy to fool the
;			Memory Manager into thinking it's both system and application heaps in order
;			to allow the heap to grow as drivers, buffers, etc. are loaded.  One subtlety
;			is that HeapEnd (which applies to the app heap) must be set up along with ApplZone.
;________________________________________________________________________________________

SetUpSysAppZone
			lea 	SysHeap,a0						; point at normal system heap template

			_InitZone								; set up initial system heap
			Move.L	theZone,SysZone 				; save pointer to the new zone
			Move.L	SysZone,RamBase					; setup RamBase to system heap

; Make the System Heap growable by making it look like the Application Heap
			MOVE.L	SysZone,A0						; Point to the System Heap
			MOVE.L	A0,ApplZone						; Make it the Application Heap as well
			MOVE.L	bkLim(A0),A0					; Point to the end of the System Heap
			MOVE.L	A0,HeapEnd						; Set it as the end of the Application Heap

; Set ApplLimit (really, ÔSysLimit') based on having a real qd-capable stack smack in the middle of RAM.

			BSR.S	CompBootStack					; A0 <- the future location of our stack
			CMPA.L	SP,A0							; Future - Current stack ptrs (want A0 = lower value)
			BLS.S	@3								; Future <= Current means use Future (be pessimistic)
			MOVE.L	SP,A0							; Use the current sp when it's lower
@3			SUBA.W	#BootStackSize,A0				; Give ourselves some stack space
			_SetApplLimit							; Don't let the System Heap crash our stack


;			_MoreMasters							; Create 768 master pointers at the bottom of			<SM132> SAM
;			_MoreMasters							; the heap.  This is approximately the number of
;			_MoreMasters							; relocatable objects in the system heap for
;			_MoreMasters							; System 7.1 and a set of standard inits.
;			_MoreMasters							; (We need 6 calls to MoreMasters to get 768 of them.
;													; _InitZone will create one block of "4*dfltMasters"
;			RTS										; MPs for us.)

			move.l	d3,-(sp)
			moveq.l	#2,d3
@trap_blk
			_MoreMasters
			_MoreMasters
			_MoreMasters
			_MoreMasters
			_MoreMasters
			_MoreMasters
			_MoreMasters
			_MoreMasters
			dbf		d3,@trap_blk
			move.l	(sp)+,d3
			rts

SysHeap		DC.L	HeapStart
			DC.L	HeapStart+SysZoneSize
			DC.W	4*dfltMasters					; Master Pointer allocation size = 128 (MPs)
			DC.L	0


;________________________________________________________________________________________
;
; Routine:	GetPRAM 6ce
;
; Inputs:	none
; Outputs:	none
; Trashes:	D0-D2, A0-A1
;
; Function:	reads in the original 20 bytes of PRAM, and sets up globals based on the saved state
;________________________________________________________________________________________

GetPRAM		_InitUtil								; seed low memory PRAM buffer

; Initialize the keyboard repeat parameters from system parameter memory.

			MOVEQ	#0,D1
			MOVE.B	SPKbd,D1						; Get keyboard rate and threshold info.
			MOVEQ	#$0F,D0
			AND.W	D1,D0							; Mask out the keyboard repeat rate.
			BNE.S	@1								; Branch if rate is valid.
			MOVEQ	#$48,D0							; If invalid, use default rate.
@1			ADD.W	D0,D0							; Convert to ticks.
			MOVE.W	D0,KeyRepThresh					; Save keyboard repeat rate.

			LSR.W	#4,D1							; Get keyboard repeat threshold.
			BNE.S	@2								; Branch if valid.
			MOVE.W	#$1FFF,D1						; If invalid, use default rate.
@2			LSL.W	#2,D1							; Convert to ticks.
			MOVE.W	D1,KeyThresh					; Save keyboard repeat threshold.

; Note: double click (dddd) and caret blink (cccc) times are stored as (ddddcccc),
; where dddd and cccc are each in fifteenths of a second.

			MOVE.B	SPClikCaret,D1					; Get double click & caret times (ddddcccc)
			MOVEQ	#$F,D0							; Caret time is in low nibble
			AND.B	D1,D0							; Compute caret time
			LSL.B 	#2,D0							; Convert to ticks
			MOVE.L	D0,CaretTime					; Save caret time (in ticks)

			LSR.B 	#2,D1							; D1 <- xxddddxx (where dddd is dbl click time)
			MOVEQ	#$3C,D0							; Double click mask
			AND.B	D1,D0							; Compute double click time in ticks
			MOVE.L	D0,DoubleTime					; Save double click time
			RTS



*************************************************************************************************
*																								*
*				G L O B A L   I N I T I A L I Z A T I O N   R O U T I N E S						*
*																								*
*************************************************************************************************


;________________________________________________________________________________________
;
; Routine:	InitHiMemGlobals 70c
;
; Inputs:	none
; Outputs:	none
; Trashes:	D0-D1, A0-A2
;
; Function:	sets up globals peculiar to the BufPtr world, which may be set by a
;			diagnostic ROM, if any
;________________________________________________________________________________________

InitHiMemGlobals
			MOVE.W	#-1,PWMValue					; set current pwm speed invalid

			move.l	BufPtr,a0						; get top of useable memory
			move.l	MemTop,A1						; get the top of total memory							<H7>

			move.l	A1,PhysMemTop					; Save top of total memory.								<H7>
			move.l	a0,RealMemTop					; Save top of available memory
			move.l	([BootGlobPtr],StartGlobals.sgPhys2Log),Phys2Log
													; <SMx> CSS get physical->logical conversion factor
			SUBA.W	#bufWorldSize,A1				; maximum BufPtr location allowed						<H7>
			CMPA.L	A1,A0							; is BufPtr still too high in memory?					<H7>
			BLS.S	@BufPtrOK						; -> no, leave it alone									<H7>
			MOVEA.L	A1,A0							; yes, move it down a bit								<H7>
@BufPtrOK	MOVE.L	A0,BufPtr						; save pointer to top of usable RAM.
			RTS										; ENDIF


;________________________________________________________________________________________
;
; Routine:	InitGlobalVars 73c
;
; Inputs:	none
; Outputs:	none
; Trashes:	D0-D1, A0-A1
;
; Function:	presets a bunch of system and toolbox globals (the Memory Manager sets up
;			a few others)
;________________________________________________________________________________________

InitGlobalVars
			Lea		BaseOfRom,A0					; point to RomBase
			MOVE.L	A0,ROMBase

			movea.l	UnivInfoPtr,a0					; get pointer to product info record
			move.w	ProductInfo.Rom85Word(a0),ROM85	; Set the Rom85 and PowerOffInt bits appropriately

			MOVE.L	#$00010001, OneOne				; set up magic constants
			MOVEQ	#-1,D0
			MOVE.L	D0, MinusOne					; set up MinusOne
			MOVE	D0,FSFCBLen 					; mark that FS needs (re)initialization
			MOVE.L	D0,SMGlobals					; no Sound Manager yet

			bsr		SetupHWBases					; Init some I/O and driver base addresses
			CLR.L	PollProc						; no proc to handle SCC poll data

			CLR.L	DSAlertTab						; no deep shit alerts yet

			BigLea 	FSIODneTbl,A0					; point to the offset table
			LEA 	JFetch,A1						; point to 1st jump table entry
			MOVEQ	#2,D1							; there are 3 vectors
			BSR 	JmpTblInit

; Initialize some system booleans so we can initialize the system properly.

			CLR.B	DskVerify						; no disk verify
			CLR.B	LoadTrap						; no trap before launch
			CLR.B	MmInOK							; initial memory mgr checks
			CLR.W	SysEvtMask						; don't allow any events to be posted
			CLR.L	JKybdTask						; no keyboard task yet
			CLR.L	StkLowPt						; set stack low at this time (turn off check during VBL)

; SoundBase really truely is an OUT-OF-DATE lowmem.  However, there's glue code, linked into
; apps/drvrs, out there that still references this guy.   Sooooo, we'll set SoundBase=ASCBase
; on ASC machines.  On non-asc machines, ie. cyclone, we'll set SoundBase to a ROM address
; so apps/drvrs will write to ROM.  We must carefully choose our ROM address.  If
; its close to a ROM jump table.  Apps/drvrs writing to @SoundBase can corrupt a ROM jump table
; in the DATA CACHE.  We'll choose the starting address of the bootbeep since its not code or
; jump table.
;
			Move.l	ROMBase,A0						; Get ROMBase
			Move.l	A0,SoundBase					; Set up SoundBase
;--------------------------------------

			LEA 	VBLQueue,A1
			BSR.L 	InitQueue						; initialize VBL queue header

			CLR.L	Ticks							; clear system tick count

			MOVE.B	#$80,MBState					; set current mouse button state to UP
			CLR.L	MBTicks 						; set timestamp for mouse button

;--------------------------------------
; Font Manager Globals

			CLR.L	SysFontFam						; clear SysFontFam and SysFontSize
			CLR.L	WidthTabHandle					; clear global width table handle
			CLR.W	teSysJust						; clear default Text justification
			CLR.B	WordReDraw						; don't draw words in RecalDraw
			CLR.L	SynListHandle					; clear handle to synthesized fonts
			MOVE.W	MinusOne,FMExist				; no InitFonts call yet

;--------------------------------------
; Clear out the nominally QD but mostly cursor variables

			BSR.S	InitCrsrVars

; leave DSAlertRect =-1 (disabled)
; leave DSDrawProc = -1 (disabled)

			CLR.W	SysVersion						; zero ram-patch version in low memory
			BCLR	#AlrmFlEnable,AlarmState		; disable alarm flashing

			BigLea 	MDJGNEFILTER,A0					; hook in our GNE filter  								<SM22>
			MOVE.L	A0,JGNEFilter					;		
			CLR.L	IAZNotify						; no InitApplZone notify proc
			MOVE.W	#$FF7F, FlEvtMask				; init for disable of DIP flushes (move to InitEvents??)

			MOVEQ	#-1,D0 							; Get -1
			MOVE.W	D0,ChunkyDepth					; no pixel depth yet
			MOVE.L	D0,CrsrPtr	 					; no cursor save area
			MOVE.L	D0,PortList	 					; no grafport list
			LEA		RGBWhite,A0						; init for color manager
			MOVE.L	D0,(A0)+						; 6 bytes for white value
			MOVE.W	D0,(A0)
			LEA		RGBBlack,A0						; init for color manager
			CLR.L	(A0)+							; 6 more bytes for black value
			CLR.W	(A0)

			CLR.L	LockMemCt						; initialize Lock Memory Count

			RTS


;________________________________________________________________________________________
;
; Routine:	InitCrsrVars 81e
;
; Inputs:	none
; Outputs:	none
; Trashes:	A0,A1
;
; Function:	initializes cursor globals
;________________________________________________________________________________________

InitCrsrVars
			LEA 	GrafBegin,A0					; start of global vars
			LEA 	GrafEnd,A1						; end of global vars
@ZeroLoop	CLR.W	(A0)+
			CMPA.L	A1,A0
			BCS.S	@ZeroLoop 						; clear out cursor globals area
			RTS


;________________________________________________________________________________________
;
; Routine:	InitCrsrMgr 82e
;
; Inputs:	none
; Outputs:	none
; Trashes:	A0,A1
;
; Function:	initializes cursor globals
;________________________________________________________________________________________

; ugly, but put here for now!
ADBCount	equ	0									; word: number of valid error deltas
MaxCnt		equ	ADBCount+2							; word: limit on number of error deltas
Err7		equ	MaxCnt+2							; word: time-7 error magnitude
Err6		equ	Err7+2								; word: time-6 error magnitude
Err5		equ	Err6+2								; word: time-5 error magnitude
Err4		equ	Err5+2								; word: time-4 error magnitude
Err3		equ	Err4+2								; word: time-3 error magnitude
Err2		equ	Err3+2								; word: time-2 error magnitude
Err1		equ	Err2+2								; word: time-1 error magnitude
Error		equ	Err1+2								; word: accumulated error
GSize		equ	Error+2								; size of globals
TotalSize	equ	GSize+8								; size of globals + size of mickey bytes

InitCrsrMgr	MOVE.L	#$000F000F,D0
			LEA 	MTemp,A0						; point to the temp mouse variable
			MOVE.L	D0,(A0)+						; put MTemp AT 15,15
			MOVE.L	D0,(A0)+						; put RawMouse AT 15,15 TOO
			MOVE.L	D0,(A0)+						; put Mouse AT 15,15 TOO
			CLR.L	(A0)+							; CrsrPin: top = 0, left = 0

			MOVE.W	ColLines,(A0)+					; set bottom
			MOVE.W	RowBits,(A0)					; set left

			moveq	#TotalSize,d0					; allocate space for mouse tracking ptr
			_NewPtr	,SYS							; put in in system heap
			move.l	a0,MickeyBytes					; save globals ptr

													; initialize some of the ADB Globals
			move.w	#1,ADBCount(a0)					;   Count = 1
			move.w	#8,MaxCnt(a0)					;   MaxCnt = 8
			clr.w	Error(a0)						;   Error = 0

													; stuff in 8 bytes to initialize tracking
			lea		MouseBytes,a1					;   source = default bytes
			add		#GSize,a0
			move.l	(a1)+,(a0)+						;   move the bytes in
			move.l	(a1),(a0)

			RTS

MouseBytes	dc.b		4,10,15,255,255,83,77,72

InitCrsrMgrMiddle
			LEA 	GrafEnd,A1						; end of cursor globals
			BigLea	CrsrDevHandleVBL,A0				; install cursor VBL task							<H9>
			MOVE.L	A0,-(A1)						; JCrsrTask
			MOVE.W	#$0006,-(A1)					; CrsrThresh

; Init the cursor jump table.  The offsets are obtained from a table in CrsrCore.

			BigLea 	InitCrTable,A0					; point to the offset table
			LEA 	JHideCursor,A1					; point to 1st jump table entry
			MOVEQ	#8-1,D1							; there are 8 vectors
			BSR 	JmpTblInit						; init vectors (destroys D0-D2)

			; A0 points to next entry in offset table
			LEA 	NewCrsrJTbl,A1					; point to 1st new jump table entry
			MOVEQ	#NewCrsrJCnt,D1					; get number of vectors
			BSR 	JmpTbl2							; init vectors (destroys D0-D2)
			LEA		HiliteRGB,A0
			MOVE.L	#$00060082,D0
			_ReadXPRam

			MOVEQ	#-1,D0							; Useful constant for cursor init
			MOVE.W	D0,CrsrNew						; flag cursor as changed, turn on tracking
			MOVE.L	D0,MouseMask					; No jerkiness with $FFFFFFFF mask

			RTS


;________________________________________________________________________________________
;
; Routine:	SetupHWBases 8be
;
; Inputs:	none
; Outputs:	none
; Trashes:	D0, D3, A0, A2, A3
;
; Function:	sets up the hardware base address low memory globals
;________________________________________________________________________________________

SetupHWBases
			with	DecoderInfo

			movem.l	d1/d2,-(sp)						; save these
			
			move.l	AddrMapFlags,d0
			move.l	AddrMapFlags1,d1				; get new bits 32-63
			move.l	AddrMapFlags2,d2				; and bits 64-96
			movea.l	UnivInfoPtr,a0
			adda.l	ProductInfo.DecoderInfoPtr(a0),a0
			lea		@BaseInitTable,a2				; point to the table
@loop		move.w	(a2)+,d3						; get the bit number
			bmi		@exit							; exit if end if table
			movea.w	(a2)+,a3						; get the low mem address

			cmpi.w	#32,d3							; above low 32 bits?
			bge.s	@chkmid32						; yes, branch
			btst.l	d3,d0							; see if the base is valid
			beq.s	@loop							; if not, skip it
			lsl.w	#2,d3							; setup index into bases table
			move.l	(a0,d3.w),(a3)					; initialize the low mem
			bra.s	@loop							; go on to next low mem

@chkmid32	sub.w	#32,d3							; it's in 32-63 range
			cmpi.w	#32,d3							; above low 32 bits?
			bge.s	@chkhigh32						; yes, branch
			btst.l	d3,d1							; see if the base is valid
			beq.s	@loop							; if not, skip it
			lsl.w	#2,d3							; setup index into bases table
			move.l	(4*32,a0,d3.w),(a3)				; initialize the low mem
			bra.s	@loop							; go on to next low mem
			
@chkhigh32	sub.w	#32,d3							; it's in 64-95 range
			btst.l	d3,d2							; see if the base is valid
			beq.s	@loop							; if not, skip it
			lsl.w	#2,d3							; setup index into bases table
			move.l	(4*64,a0,d3.w),(a3)				; initialize the low mem
			bra.s	@loop							; go on to next low mem



@BaseInitTable
			dc.w	VIA1Exists,VIA					; init VIA1 base address
			dc.w	SCCRdExists,SCCRd				; init SCC read base address
			dc.w	SCCWrExists,SCCWr				; init SCC write base address
		IF hasIopScc THEN
			dc.w	SCCIOPExists,SCCRd				; init SCC IOP read base address
			dc.w	SCCIOPExists,SCCWr				; init SCC IOP write base address
		ENDIF
			dc.w	IWMExists,IWM					; init IWM base address
		IF hasIopSwim THEN
			dc.w	SWIMIOPExists,IWM				; init SWIM IOP base address
		ENDIF
		IF hasSwim3 THEN
			dc.w	SWIM3Exists,IWM					; init SWIM3 base address
		ENDIF
			dc.w	PWMExists,PWMBuf1				; init primary PWM buffer
			dc.w	PWMExists,PWMBuf2				; init secondary PWM buffer
			dc.w	SoundExists,SoundBase			; init sound buffer base address
			dc.w	SCSIExists,SCSIBase				; init SCSI base
			dc.w	SCSIDackExists,SCSIDMA			; init SCSI Dack base
			dc.w	SCSIHskExists,SCSIHsk			; init SCSI Dack base
		IF hasMac2VIA2 | hasEclipseVIA2 THEN
			dc.w	VIA2Exists,VIA2					; init VIA2 base address
		ENDIF
		IF hasASC THEN
			dc.w	ASCExists,ASCBase				; init ASC base address
		ENDIF
		IF hasRBV THEN
			dc.w	RBVExists,RBV					; init RBV base address
		ENDIF
			dc.w	SCSIDMAExists,SCSIBase			; init SCSI DMA base addresses
			dc.w	SCSIDMAExists,SCSIDMA			; init SCSI DMA base addresses
			dc.w	SCSIDMAExists,SCSIHsk			; init SCSI DMA base addresses
		IF hasOSS THEN
			dc.w	OSSExists,OSS					; init OSS base address
		ENDIF
			dc.w	-1								; end of list


@exit

; Setup miscellaneous low mem SCSI addresses
; Existing Mac SCSI systems are either 80-base or 96-based
;
; a0 -> base of address table
; d0 -> Addresses Map Flags, which system addresses are valid

SetupMiscSCSI
		IF hasSCSI96 THEN
			btst.l	#SCSI96_1Exists, d0				; see if we have 1st SCSI96
			beq.s	@2ndSCSI96						; bra. if not
			move.l	SCSI96Addr1(a0), SCSIBase		; initialize the low mem								<SM82>
@2ndSCSI96			
			btst.l	#SCSI96_2Exists, d0				; see if we have 2nd SCSI96
			beq.s	@80based						;
			move.l	SCSI96Addr2(a0), SCSI2Base		; initialize the low mem								<SM82>
			bra.s	@SCSIHskDone
@80based
		ENDIF


			btst.b	#6, ($2400)
			bne.b	@SCSIHskDone

			btst.l	#SCSIDackExists,d0				; see if we have SCSI Dack
			bne.s	@SCSIDackDone					; if we do, it's setup ok
			move.l	SCSIHsk,SCSIDMA					; if not, use hsk instead
@SCSIDackDone

			btst.l	#SCSIHskExists,d0				; see if we have SCSI Hsk
			bne.s	@SCSIHskDone					; if we do, it's setup ok
			move.l	SCSIDMA,SCSIHsk					; if not, use Dack instead
@SCSIHskDone

			movem.l	(sp)+,d1/d2
			
			rts										; all done
			endwith



;________________________________________________________________________________________
;
; Routine:	InitSlots 992
;
; Inputs:	none
; Outputs:	none
; Trashes:	D0, A0
;
; Function:	initializes the slot dispatch table, gives the Slot Manager its wakeup call,
;			and grays the screen for devices with video cards
;________________________________________________________________________________________

InitSlots	BSR.L	InitSDTbl						; init slot int dispatch table
			BSR.L	InitVBLQs						; init VBLqueues for all slots

			BSR.L	StartSDeclMgr					; init the slot manager
			BNE.S	@SlotError						; branch if an error occurred
			RTS

@SlotError	MOVE.L	D0,D6							; save error code
			MOVEQ	#$1F,D7							; NuMac Error
			BRA		Critical						; Critical error


;________________________________________________________________________________________
;
; Routine:	InitDeviceMgr 9b0
;
; Inputs:	none
; Outputs:	none
; Trashes:	???
;
; Function:	initializes the I/O system by building the Unit Table 
;________________________________________________________________________________________

InitDeviceMgr	; Compute the size of the unit table and allocate it.

			MOVEQ	#UnitEntries,D0 				; get number of entries in unit table
			MOVE.W	D0,UnitNtryCnt					; save for IOCore checking

			MOVE.L	#MaxUTEntries*2,D0				; reserve more memory so table can grow					<SM84>
			_NewPtr ,SYS,CLEAR						; allocate it and zero out the memory
			MOVE.L	A0,UTableBase					; and save its address

			rts
			
			
;________________________________________________________________________________________
;
; Routine:	LoadDrivers 9c4
;
; Inputs:	none
; Outputs:	none
; Trashes:	???
;
; Function:	issues initialization calls to all the component drivers.
;________________________________________________________________________________________

LoadDrivers
;
;ÑÑÑÑÑÑÑÑÑ  Floppy Driver  ÑÑÑÑÑÑÑÑÑ
;
			LEA 	-IOQElSize(SP),SP				; allocate parameter block for device manager calls
			MOVE.L	SP,A0
			CLR.B	IOPermssn(A0)					; r/w permissions

;
;ÑÑÑÑÑÑÑÑÑ  RAM Disk Driver  ÑÑÑÑÑÑÑÑÑ
;
; if we don't have an EDisk driver, this will not affect anything
; to enable the EDisk, make sure that it is included in the rom resources

		IF hasEDisk THEN
			LEA.L 	EDiskName,A1					
			MOVEQ.L	#$30,D2							;  and resource ID										<SM84>
			BSR		InstallDriver					; go install the driver									<SM84>
		ENDIF


;
;ÑÑÑÑÑÑÑÑÑ  LAN Disk Driver  ÑÑÑÑÑÑÑÑÑ
;

			IMPORT	InterC_1890_InitLANDisk
			BSR		InterC_1890_InitLANDisk


;
;ÑÑÑÑÑÑÑÑÑ  BCScreen Driver  ÑÑÑÑÑÑÑÑÑ
;


			IF		hasBCScreen THEN

			SubQ.L	#$2, sp
			Move.L	sp, -(sp)
			Move.L	#$3FF, -(sp)
			Move.L	#$36, -(sp)
			Clr.L	-(sp)
			Pea.L	BCScreenName
			Move.L	#$FFFFBF7D, -(sp)

			IMPORT	Interstix208c_1
			BSR.L	Interstix208c_1

			dc.w	$defc, $001a
			;AddA	#$1A, A7

			ENDIF


;
;ÑÑÑÑÑÑÑÑÑ  Backlight Driver  ÑÑÑÑÑÑÑÑÑ
;

		IF hasPwrControls THEN
			BTst.B    #$0, (HWCfgFlags)
			BEQ.B     @noBacklight
			BTst.B    #$6, ($2409)
			BNE.B     @noBacklight
			Move.L    #'only', -(A7)
			LEA.L	BacklightName,A1				; get the backlight driver's name						<SM84>
			MOVE.W	#-16511,D2						;  and resource ID										<SM84>
			BSR		InstallDriver					; go install the driver									<SM84>
			AddQ      #$4, A7
@noBacklight
	
			  MoveA.L   A7, A0
			  Clr.B     $1B(A0)
			  Bsr       FROVideo
			  Lea.L     $32(A7), A7
			  BTst.B    #$6, ($2409)
			  BEQ.B     @skipALine
			  import	InterC_1f40_Backlight
			  Bsr.L     InterC_1f40_Backlight
@skipALine

			  BTst.B    #$3, ($DD3)
			  BEQ       @exitDrivers
		ENDIF






;
;ÑÑÑÑÑÑÑÑÑ  Serial Drivers  ÑÑÑÑÑÑÑÑÑ
;
; The ROM serial driver is stored in a resource of type 'SERD'. The classic serial driver
; is 'SERD' (0) and the SerialDMA serial driver is 'SERD' (1). Which serial driver to use
; is indicated by a bit in Universal ProductInfo. A 'SERD' resource is a code resource
; whose entry point is an installation procedure. A 'SERD' installs itself into the unit
; table, remaining closed and inactive until opened by a client.

			subq	#4,sp							; allocate space for return value
			move.l	#'nsrd',-(sp)					; push serial driver resource type
			move.w	#1,-(sp)						; SerialDMA driver is 'SERD' (1)
			move.w	#mapTrue,ROMMapInsert			; get resource from ROM
			_GetResource
			move.l	(sp)+,d0						; did it get the handle?
			beq.b	@exitDrivers
			movea.l	d0,a2
			movea.l	(a2),a1
			SubQ      #$4, A7
			Move.L    A2, -(A7)
			dc.w $a9a5 ; _SizeResource
			Move.L    (A7)+, D1
			Move.L    D1, D0
			dc.w $A440 ; _ResrvMemSys
			Move.L    D1, D0
			_NewHandle ,Sys
			Move.L    A0, D0
			BEQ.B     (* + $E)
			_HLock
			Move.L    D1, D0
			MoveA.L   (A0), A1
			MoveA.L   (A2), A0
			_BlockMove
			jsr		(a1)							; call the install code

@exitDrivers
			rts


			STRING	PASCAL

SndName 	DC.W	'.Sound'						;														<SM83>

		IF hasEDisk THEN
EDiskName	DC.W	'.EDisk'						;														<SM83>
		ENDIF
		IF hasNewAge THEN
NewAgeName	DC.W	'.NewAge'						;														<SM16>
		ENDIF
		IF hasNetBoot THEN
NetBootName	DC.W	'.netBOOT'
		ENDIF

		IF hasPwrControls THEN
BacklightName
			DC.W	'.Backlight'
		ENDIF


		IF hasBCScreen THEN
BCScreenName
			DC.W	'.BCScreen'
		ENDIF


			STRING	ASIS


*************************************************************************************************
*																								*
*									V I D E O   R O U T I N E S									*
*																								*
*************************************************************************************************


;________________________________________________________________________________________
;
; Routine:	DrawBeepScreen ab0
;
; Inputs:	A5	-	pointer to QuickDraw globals in boot globals space
;
; Outputs:	none
;
; Trashes:	D0-D2, A0-A1
;
; Function:	Grays the screen (with rounded corners on non-LCD screens) using Horst's
;			patented methods.  The use of QuickDraw here forces existance of a temporary
;			app heap during system initialization time.
;________________________________________________________________________________________

DrawBeepScreen
			PEA 	-4(A5)							; set up QuickDraw global area
			_InitGraf

			PEA 	BootGlobals.port(a5)			; let Grafport be above A7, A5							<SM56>
			_OpenCPort								; open default COLOR port (closed in StartBoot)

			MOVE.L	(A5),A2 						; point to QuickDraw globals
			PEA 	arrow(A2)						; show the arrow cursor
			_SetCursor

		IF hasPwrControls THEN						;														<SM81>
;	if built-in video is an LCD screen, use square corners to avoid "eyebrows" on the top ends
;	of the menu bar (because the screen background is white on LCD screens vs black on CRTs)

			BSR.L	LCDScreenChk					; is this an LCD screen ? 								<SM16><SM68>
			BEQ.B	@DoNormalBeepScreen				; -> no, do the normal stuff							<SM16><SM68>
			
			CLR.B	ntsc

			PEA 	ScreenBits+bounds(A2)			;  screen rectangle										<SM84>
			CLR.B	-(SP)
			IMPORT	INTERC_2B20_GRAYPAGE
			JSR		INTERC_2B20_GRAYPAGE
			TST.B	(SP)+
			BNZ.B	@graypage_returned_nonzero

;graypage_returned_zero
			PEA		gray(A2)						;  fill pattern
			BRA.B	@graypage_endif

@graypage_returned_nonzero
			MOVE.L	ExpandMem,A0
			ST.B	$341(A0)
			PEA		@GrayColor
			_RGBForeColor
			PEA		black(A2)

@graypage_endif

			_FillRect

			MOVEQ	#5,D0
			DC.W	$ABE0 ; QDExtensions2, ?showCursor selector

			RTS
@DoNormalBeepScreen
		ENDIF										;														<SM81>

;	for normal screens (CRTs), draw the screen with rounded corners

			LEA		ScreenBits+bounds+8(A2),A0		; make a copy of the screen rectangle
			LEA		TempRect+8,A1
			MOVE.L	-(A0),-(A1)
			MOVE.L	-(A0),-(A1)

			MOVE.L	A0,-(SP)						; push the screen rectangle for FillRoundRect
			MOVE.L	A1,-(SP)						; push the copy for FrameRoundRect
			MOVE.L	A1,-(SP)						;  and for InsetRect
			MOVE.L	#$FFFDFFFD,-(SP)				; make the rectangle bigger by 3 on each side
			_InsetRect

			MOVE.L	#$00030003,-(SP)				; make pen 3 pixels wide.
			_PenSize

			MOVE.L	#$00160016,-(SP)				; rounding factor ($00100010 + 2 * $00030003)
			_FrameRoundRect							; draw black corners without flicker

			_PenNormal								; restore the pen

			PEA		@GrayColor
			_RGBForeColor

			MOVE.L	#$00100010, -(SP)				;  rounding factor
			PEA 	black(A2)						;  fill pattern
			BRA.B	@skipOldPatternSelection

			MOVE.L	#$00100010, -(SP)				;  rounding factor
			PEA 	gray(A2)						;  fill pattern
@skipOldPatternSelection
			_FillRoundRect							; fill the screen with 50% gray

			MOVEQ	#5,D0
			DC.W	$ABE0 ; QDExtensions2, ?showCursor selector

			RTS

@GrayColor
			DC.W	$8888, $8888, $8888



;________________________________________________________________________________________
;
; Routine:	FROVideo b54
;
; Inputs:	A0	-	pointer to ioParamBlock
;
; Outputs:	none
;
; Trashes:	D0-D2, A0-A2
;
; Function:	finds, reads parameters for, and opens the driver for a video sRsrc
;________________________________________________________________________________________

			WITH	spBlock,seBlock,vpBlock

FROVideo	MOVE.L	A0,A1							; save the param block pointer for _Open

			LINK	A6,#-spBlockSize				; allocate space for a slot parameter block
			MOVE.L	SP,A0							;  and point to it

			BTST.B	#6, ($240B)
			BEQ.B	@TryDefault

			MoveM.L   D0-D7/A0-A4, -(A7)
			Move.L    ($1FB8), -(A7)
			MoveA.L   ($2b6), A3
			MoveA.L   $1E0(A3), A3
			Move.L    $C(A3), -(A7)
			Lea.L     (* + $28A), A2
			Move.L    A2, ($1FB8)
			Move.L    A2, $C(A3)
			SubQ      #$2, A7
			Clr.L     -(A7)
			Move      #$2EB, D0
			_DisplayDispatch
			Move      (A7)+, D0
			MoveA.L   ($2b6), A3
			MoveA.L   $1E0(A3), A3
			Move.L    (A7)+, $C(A3)
			Move.L    (A7)+, ($1FB8)
			Tst       D0
			MoveM.L   (A7)+, D0-D7/A0-A4
			BNE.B     @End

@TryDefault
			BSR		OpnVidDeflt						; open the default video device, set video params
			BEQ		@End							; -> got it

;	the default video device is bad, so go search for a video sRsrc...

			MOVE.L	#(CatDisplay<<16) ++ TypVideo, spCategory(A0)	;	stuff Category and Type, looking
													;	 for an Apple compatible video card
			MOVE.W	#DrSwApple,spDrvrSw(A0)			;	want Apple driver software interface
			MOVE.B	#1,spTBMask(A0)					;	mark spDrvrHw field as don't care
			CLR.B	spSlot(A0)						;	start with slot #0
			CLR.B	spId(A0)						;	start with sResource ID #0
			CLR.B	spExtDev(A0)					;	no external devices

;	keep looking for a video driver until we find one that we can open...

@NextVidsRsrc
			_sNextTypesRsrc							; search for a video sRsrc
			BNE		@End							; -> couldn't find one, so allocate a dummy screen

			BSR		OpensDrvr						; open the video driver
			BNE.S	@NextVidsRsrc					; -> couldn't do it, so go look some more

			MOVE	$18(A1), -(SP)
			BSR		RdVidParam						; read the video parameters
			TST		D0
			BNE.S	@NextVidsRsrc					; -> error, so go search some more

			BSR		InitVidDeflt					; initialize the default video device
			BNE.S	@NextVidsRsrc					; -> error during initialization, so go looking

			BRA.S	@End

			BSR		InitDummyScreenWrapper

@End		UNLK	A6								; get rid of the slot parameter block
			RTS


;________________________________________________________________________________________
;
; Routine:	OpnVidDeflt bfa
;
; Inputs:	A0	-	pointer to Slot Manager parameter block
;			A1	-	pointer to ioParamBlock
;
; Outputs:	CCR	-	BEQ if successful, BNE if failure
;
; Trashes:	D0-D2, A2
;
; Function:	opens the default video device
;________________________________________________________________________________________

OpnVidDeflt	MOVE.L	A0,A2							; save A0

			SUBQ.W	#2,SP							; allocate space for parameter RAM info
			MOVE.L	SP,A0							;  and point to it
			_GetVideoDefault						; get the default video info
			MOVE.B	(A0)+,spSlot(A2)				; save the slot number
			MOVE.B	(A0)+,spId(A2)					;  and ID
			ADDQ.W	#2,SP							; (clean up the stack)

			MOVE.L	A2,A0							; restore A0
			CLR.B	spExtDev(A0)					;	no external devices
			_sRsrcInfo								; get the sResource Type
			BNE.S	@Error							; -> error

			CMP.L	#(CatDisplay<<16) ++ TypVideo,spCategory(A0)	; are the category and type correct?
			BNE.S	@Error							; -> no, keep on searching
			CMP.W	#DrSwApple,spDrvrSW(A0)			; does it have an Apple driver interface (software only)?
			BNE.S	@Error							; -> no, keep on searching

			BSR		OpensDrvr						; open the video driver
			BNE.S	@Error							; -> couldn't do it

			MOVE	$18(A1), -(SP)
			BSR		RdVidParam						; a video sRsrc was found, so read the video parameters
			TST		D0
			BNE.S	@Error							; -> error during the read

			BSR		InitVidDeflt					; initialize the default video device
@Error		RTS


;________________________________________________________________________________________
;
; Routine:	RdVidParam c42
;
; Inputs:	A0	-	pointer to Slot Manager parameter block
;			A1	-	pointer to ioParamBlock
;
; Outputs:	CCR	-	BEQ if successful, BNE if failure
;
; Trashes:	D0
;
; Function:	Searches the video card ROM for expected video parameters.  These values are
;			then saved in low memory as needed.
;________________________________________________________________________________________

RdVidParam	LINK	A6, #-$94
			MOVEM.L	A0-A2/D3,-(SP)
			MOVE.B	spId(A0),D3						; save the ID

			CLR.B	spExtDev(A0)					;	no external devices
			_sRsrcInfo								; get a pointer to the sRsrc list
			BNE		@Error

			_sFindDevBase							; get the device base address
			BNE		@Error							; -> error
			MOVE.L	spResult(A0),ScrnBase			; save it as screen base.

			MOVE.B	#MinorLength,spId(A0)
			_sReadLong								; get the total number of bytes occupied by screen sRsrc
			BEQ  	@gotBase						; got it, save away
			
			MOVE.B	#MajorLength,spId(A0)			; else, try major length (some don't support minor length)	<SM144>
			_sReadLong								; get the total number of bytes occupied by screen sRsrc	<SM144>
			BNE  	@Error							; -> couldn't find it										<SM144>

@gotBase	MOVE.L	spResult(A0),ScreenBytes		; save it

			MOVE.B	D3,spId(A0)						; restore the sRsrc ID
			MOVE	$18(A1), -(SP)
			BSR		GetDefVidMode					; get the default video mode
			MOVE.B	D0,spId(A0)						;  and save it

			_sFindStruct							; go look up the default video mode
			BNE		@Error							; -> default mode is not supported

			MOVE.B	#mVidParams,spId(A0)			;	ID for video sBlock
			_sGetBlock								; go get it
			BNE		@Error							; -> not found
			MOVE.L	spResult(A0),A1					; save the pointer to the parameter block

;	save required parameters in low memory globals:

			MOVE.W	vpBounds+4(A1),ColLines			; screen height
			MOVE.W	vpBounds+6(A1),RowBits			; screen width
			MOVE.W	vpRowBytes(A1),D0				;
			MOVE.W	D0,ScreenRow					; screen rowBytes
			MOVE.W	D0,CrsrRow						; cursor's screen rowBytes
			MOVE.W	vpVRes(A1),ScrVRes				; vertical resolution
			MOVE.W	vpHRes(A1),ScrHRes				; horizontal resolution
			MOVE.L	vpBaseOffset(A1),D0				; update the screen base
			ADD.L	D0,ScrnBase
			MOVE.L	ScrnBase,CrsrBase				;  and the cursor base address

			MOVEQ	#0,D0
			MOVE.B	spSlot(A0),D0					; get the slot number
			_AttachVBL								; setup the VBL connection for the main video card

			MOVE.L	#VideoMagic,VideoInfoOK			; show that the video info is available

			MOVE.L	A1,spsPointer(A0)				;	pointer to parameter block
			_sDisposePtr							; all done, dispose it
			MOVEQ	#0,D0							; no errors

@End		MOVE.B	D3,spId(A0)						; restore ID for caller
			MOVEM.L	(SP)+,A0-A2/D3
			UNLK	A6
			RTD		#2

@Error		MOVEQ	#1,D0							; bad video card (woof)
			BRA.S	@End


;________________________________________________________________________________________
;
; Routine:	OpensDrvr d0a
;
; Inputs:	A0	-	pointer to Slot Manager parameter block
;			A1	-	pointer to ioParamBlock
;
; Outputs:	CCR	-	BEQ if successful, BNE if failure
;
; Trashes:	D0-D1
;
; Function:	opens a slot driver
;________________________________________________________________________________________

OpensDrvr	MOVE.L	A2,-(SP)

			LEA		-seBlockSize(SP),SP				; allocate an sExec parameter block,
			MOVE.L	SP,A2							;  point to it,
			MOVE.L	A2,spsExecPBlk(A0)				;  and save a copy in the slot PB

			LEA		-256(SP),SP						; allocate space for the driver's name
			MOVE.L	SP,spResult(A0)					;  and save it in the PB
			_sReadDrvrName							; read the name of the driver
			BNE.S	@End							; -> error

			MOVE.L	spResult(A0),seIOFileName(A2)	; name of driver, for seBlock
			MOVE.B	spSlot(A0),seSlot(A2)			; slot,
			MOVE.B	spId(A0),sesRsrcId(A2)			; sRsrc,
			CLR.B	seDevice(A2)					; and device,

			MOVE.L	seIOFileName(A2),ioFileName(A1)	; copy the driver name pointer to ioFileName.
			CLR.L	ioMix(A1)						; this field should be 0
			CLR.W	ioFlags(A1)						; clear the flags
			BSET.B	#fMulti,ioFlags+1(A1)			; set the Multi bit
			MOVE.L	A2,ioSEBlkPtr(A1)				; point to the seBlock (for sLoad record)
			CLR.B	ioPermssn(A1)					; R/W permissions
			EXG.L	A0,A1							; A0=pointer to ioParamBlock, A1=pointer to slot PB
			_Open	,IMMED							; open the video driver, using the extended parameter block
													; (keep error code and CCR through to RTS)
			EXG.L	A0,A1							; restore A0,A1

@End		LEA		256+seBlockSize(SP),SP			; clean up the stack
			MOVE.L	(SP)+,A2
			RTS


;________________________________________________________________________________________
;
; Routine:	InitVidDeflt
;
; Inputs:	A0	-	pointer to Slot Manager parameter block
;			A1	-	pointer to ioParamBlock
;
; Outputs:	none
;
; Trashes:	D0-D1
;
; Function:	allocates a GDevice for the default video device
;________________________________________________________________________________________

InitVidDeflt
			MOVEM.L	D1-D2/A0-A3,-(SP)				; save all registers
			SubQ      #$4, A7
			MoveA.L   A7, A2
			Move      $18(A1), -(A7)
			Bsr       GetDefVidMode
			Move.L    ($1FB8), -(A7)
			MoveA.L   ($2b6), A3
			MoveA.L   $1E0(A3), A3
			Move.L    $C(A3), -(A7)
			Lea.L     InitVidDeflt_RTS, A3
			Move.L    A3, ($1FB8)
			Move.L    A3, (12)
			SubQ      #$4, A7
			MoveA.L   A7, A3
			SubQ      #$2, A7
			Move.L    A3, -(A7)
			Move      $18(A1), -(A7)
			Move.L    D0, -(A7)
			Clr.L     -(A7)
			Clr.L     -(A7)
			Clr.L     -(A7)
			Clr.L     -(A7)
			Move      #$D23, D0
			_DisplayDispatch
			Move      (A7)+, D0
			MoveA.L   (A7)+, A3
			Tst       D0
			BNE.B     @skip
			SubQ      #$2, A7
			Move.L    A3, -(A7)
			Move.L    A2, -(A7)
			Clr.B     -(A7)
			Move      #$51F, D0
			_DisplayDispatch
			Tst       (A7)+
			BNE.B     @skip
			SubQ      #$2, A7
			Move.L    A3, -(A7)
			Clr.L     -(A7)
			Move      #$40B, D0
			_DisplayDispatch
			Tst       (A7)+
			BNE.B     @skip
			SubQ      #$2, A7
			Move.L    (A2), -(A7)
			Move.L    A2, -(A7)
			Clr.B     -(A7)
			Move      #$520, D0
			_DisplayDispatch
			Tst       (A7)+
			BNE.B     @skip
			MoveA.L   (A2), A0
@skip
			MoveA.L   ($2b6), A3
			MoveA.L   $1E0(A3), A3
			Move.L    (A7)+, $C(A3)
			Move.L    (A7)+, ($1FB8)
			AddQ      #$4, A7

			BSR		InitDefGamma					; initialize gamma correction for this device

			MOVEM.L	(SP)+,D1-D2/A0-A3				;restore all registers
			MOVEQ	#0,D0							;no error
			RTS


InitVidDeflt_RTS
			RTS


;________________________________________________________________________________________
;
; Routine:	GetDefVidMode
;
; Inputs:	A0	-	pointer to Slot Manager parameter block
;
; Outputs:	D0	-	default video mode
;
; Trashes:	none
;
; Function:	returns the default video mode for the device specified in the slot PB
;________________________________________________________________________________________

GetDefVidMode
			LINK	A6, #-$58

			MOVE.L	spsPointer(A0),-(SP)			; save the sPointer,
			MOVE.B	spId(A0),-(SP)					;  the id,
			MOVEM.L	A1-A2,-(SP)						;  and registers

			LEA		-SizesPRAMRec*3(A6),A1			; make room for parameter RAM info
			MOVE.L	A1,(A0)							;  and point to it

			_SReadPRAMRec							; get parameter RAM record
			BNE.S	@OneBit							; -> it's invalid, so default to one bit mode

			CLR.B	spExtDev(A0)					;	no external devices
			_sRsrcInfo								; get a pointer to the sResource list
			BNE.S	@OneBit							; -> error

			MOVE.B	2(A1),spId(A0)					; check for a valid mode
			_sFindStruct
			BNE.S	@OneBit							; -> not valid

			MOVEQ	#0,D0
			MOVE.B	2(A1),D0						; get the default mode

@ValidMode	MOVEM.L	(SP)+,A1-A2						; restore registers,
			MOVE.B	(SP)+,spId(A0)					;  the id,
			MOVE.L	(SP)+,spsPointer(A0)			;  and the sPointer
			UNLK	A6
			RTD		#2

@OneBit		MOVE.B	#OneBitMode,2(A1)				; Set default to OneBitMode
			MOVE.L	A1,spsPointer(A0)				; Pass pointer to buffer
			_SPutPRAMRec							; Save parameter RAM record
			MOVE.L	#OneBitMode,D0					; Assume one bit mode
			BRA.S	@ValidMode						; Branch if mode is valid


;________________________________________________________________________________________
;
; Routine:	InitDefGamma e64
;
; Inputs:	A0	-	handle to GDevice
;
; Outputs:	none
;
; Trashes:	D0, A0, A1
;
; Function:	Sets the default gamma correction table for the device.  This routine is
;			updated to look in the video card's gamma directory for the default gamma
;			table.  If a gamma directory is not found, then this routine leaves the
;			gamma table unchanged from its default.  If the card is an original Mac II
;			Video Card (TFB card), then it sets the default gamma from the ROM resource.
;			For all other cards it leaves the gamma table unchanged if a directory is
;			not found.
;________________________________________________________________________________________

IOPBlk		EQU		-IOVQElSize						; [64] parameter blk for I/O calls
VidParms	EQU		IOPBlk-12						; [12] size of mode params
VARSIZE		EQU		VidParms						; size of locals

InitDefGamma
			LINK	A6,#VARSIZE						; allocate local stack frame
			MOVEM.L	A2/A3,-(SP)						; save work registers
			MOVE.L	A0,A2							; save GDevice

; find the video sRsrc list based on the gDevice's gdRefnum.

			MOVE.L	(A2),A1							; de-reference the GDevice handle
			MOVE.W	gdRefNum(A1),D0					;  and get the device's refnum
			NOT.W	D0								; invert it to make an index
			MOVE.L	UTableBase,A1					; get the unit table base
			MOVE.L	(A1,D0*4),A1					; get DCE handle
			MOVE.L	(A1),A1							;  and de-reference it
			LEA		-spBlockSize(SP),SP				; allocate a Slot Manager parm block
			MOVE.L	SP,A0							;  and point to it
			MOVE.B	dCtlSlot(A1),spSlot(A0)			; 	slot number
			CLR.W	spID(A0)						;	zero spID, spExtDev
			MOVE.W	#CatDisplay,spCategory(A0)		;	look for this slot's card
			MOVE.W	#TypVideo,spCType(A0)
			MOVE.W	#DrSwApple,spDrvrSW(A0)
			MOVE.B	#1,spTBMask(A0)					;	mark spDrvrHw field as don't care
			_sNextTypesRsrc							; get the spsPointer
			BNE.S	@Error							; -> couldn't get it

			CMP.W	#DrHwTFB,spDrvrHW(A0)			; is this a TFB card?
			BEQ.S	@DoTFB							; -> yup, so get the gamma resource from ROM

; get the default gamma from the video card's gamma directory.  Keep the temp handle in A3

			MOVE.B	#sGammaDir,spID(A0)				; look for the gamma directory
			_sFindStruct							; get that baby
			BNE.S	@Error							; -> not present

			MOVE.B	#128,spID(A0)					; get the default gamma table, (always 128)
			_sReadPBSize							; read the physical block size
			BNE.S	@Error							; -> not present										<SM60>

			MOVE.L	A0,A3							; save the slot parameter block for a second
			MOVE.L	spSize(A0),D0					; get the table size
			_NewHandle								; allocate it
			BNE.S	@Error							; if you couldn't get it, then bail out					<SM60>
			_HLock									; lock it down
			EXG.L	A0,A3							; get handle in A3, spBlock back in A0
			MOVE.L	(A3),A1							; get pointer to the block
			MOVE.L	A1,spResult(A0)					; point slot manager toward this buffer
			SUBQ.W	#4,spSize(A0)					; subtract block header from size
			_sReadStruct							; read the data into the handle
			BNE		@Error							; something went wrong									<SM60>
			MOVE.L	spResult(A0),A0					; get gamma table ptr in A0

; skip over header

			ADDQ.W	#2,A0							; skip resID
@Name		TST.B	(A0)+							; skip over gamma name
			BNE.S	@Name
			MOVE.L	A0,D0
			ADDQ.L	#1,D0							; round up the pointer
			ANDI.B	#$FE,D0							;  and word-align it
			MOVEA.L	D0,A0							;  then put it back in A0

; now call the driver to set this gamma table (handle on stack)

@SetIt		LEA		VidParms(A6),A1					; point to params for SetGamma
			MOVE.L	A0,csGTable(A1)					; gamma table pointer is only param
			LEA		IOPBlk(A6),A0					; point to parameter block
			MOVE.L	A1,csParam(A0)					; move addr of parms into block
			MOVE.W	#4,csCode(A0)					; csc_SetGamma
			CLR.L	ioCompletion(A0)				; no completion routine
			CLR.W	ioVRefNum(A0)					; no volRefNum
			MOVE.L	(A2),A1							; point to gdevice
			MOVE	GDRefNum(A1),ioRefNum(A0)		; set device's refnum
			_Control ,IMMED							; SetGamma(GammaTable);
			MOVE.L	A3,A0							; get handle to gamma table
			_HUnlock								; unlock the gamma table
			_DisposHandle							; and get rid of it

@Error		ADDA	#spBlockSize,SP					; release the slot parameter block
			MOVEM.L	(SP)+,A2/A3						; restore all registers
			UNLK	A6								; strip stack frame
			RTS

; get the default gamma table from ROM

@DoTFB		SUBQ	#4,SP							; make room for function result
			MOVE.L	#'gama',-(SP)					; push gamma table rsrc type
			CLR		-(SP)							; get 'gama' resource 0
			MOVE.W	#MapTRUE,ROMMapInsert 			; get from ROM
			_GetResource							; try to read in gamma table
			MOVE.L	(SP),-(SP)						; push a copy
			_DetachResource							; make it a handle
			MOVE.L	(SP)+,A0						; get handle to gamma table
			_HLock									; lock down the gamma table
			MOVE.L	A0,A3							; remember it in A3
			MOVE.L	(A0),A0							; get gamma table ptr in A0
			BRA.S	@SetIt							; set it


InitDummyScreenWrapper ; f52
			MOVE.L	(DeviceList), D0
			BEQ.B	InitDummyScreen
			CMPI.L	#$FFFFFFFF, D0
			BEQ.B	InitDummyScreen
			RTS


;________________________________________________________________________________________
;
; Routine:	InitDummyScreen f62
;
; Inputs:	none
; Outputs:	none
; Trashes:	D0-D2, A0-A1
;
; Function:	allocates all the necessary structures for operation without a screen device
;________________________________________________________________________________________

; First allocate bits for a dummy screen.  Make it 32*32 just for fun!

InitDummyScreen
			MOVEQ	#32,D0							; get height of screen
			MOVE.W	D0,ColLines						; save number of columns
			MOVE.W	D0,RowBits						; save number of rows

			MOVEQ	#4,D0							; get byte width of screen
			MOVE.W	D0,ScreenRow					; save rowbytes of screen
			MOVE.W	D0,CrsrRow						; save rowbytes of cursor

			MOVEQ	#(32*4)/2,D0					; get size of screen
			ADD.L	D0,D0
			MOVE.L	D0,ScreenBytes					; save size of screen
			_NewPtr									; allocate screen memory
			MOVE.L	A0,ScrnBase						; save base of screen
			MOVE.L	A0,IconTLAddr					; save base for icon
			MOVE.L	A0,CrsrBase						; save base for cursor

			MOVEQ	#$0048,D0						; get screen resolution
			MOVE.W	D0,ScrHRes						; save horiz resolution
			MOVE.W	D0,ScrVRes						; save vert resolution

; allocate a dummy GDevice, and set up all devices

			CLR.L	-(SP)							; make room for result
			CLR		-(SP)							; no refNum
			MOVEQ	#-1,D0							; get mode = -1
			MOVE.L	D0,-(SP)						; and push mode -1
			_NewGDevice								; allocate and init GDevice
			MOVE.L	(SP)+,A0						; get gDevice

			MOVE.L	A0,theGDevice					; set theGDevice
			MOVE.L	A0,DeviceList					; set head of device list
			MOVE.L	A0,MainDevice					; set as first device
			MOVE.L	A0,SrcDevice					; set as src device
			MOVE.L	A0,CrsrDevice					; and as cursor device

; initialize the GDevice's pixMap

			MOVE.L	(A0),A1							; point to gdevice
			MOVE	#4,GDResPref(A1)				; set preferred resolution
			MOVE.W	#(1<<screenActive)|\			; flags: in use
					 (1<<noDriver)|\				;		 no driver for this GDevice
					 (1<<screenDevice)|\			;		 screen device [not used]
					 (1<<allInit)|\					;		 all devices initialized
					 (1<<mainScreen)|\				;		 main screen
					 (1<<ramInit),GDFlags(A1)		;		 initialized from 'scrn' resource
			MOVEQ	#32,D0							; get height and width
			MOVE	D0,GDRect+bottom(A1)			; get the device rectangle's bottom and right
			MOVE	D0,GDRect+right(A1)
			MOVE.L	GDPMap(A1),A0					; get handle to pixMap
			MOVE.L	(A0),A0							; point to pixMap
			MOVE.L	scrnBase,baseAddr(A0)			; set base address
			MOVE	screenRow,rowBytes(A0)			; set rowbytes
			MOVE	D0,bounds+right(A0)				; set bounds
			MOVE	D0,bounds+bottom(A0)			; right and bottom
			MOVEQ	#$48,D0							; get resolution
			SWAP	D0								; put in high word for fixed
			MOVE.L	D0,hRes(A0)						; save as horizontal res
			MOVE.L	D0,vRes(A0)						; and as vRes
			MOVEQ	#1,D0							; get a useful number
			MOVE	D0,pixelSize(A0)				; pixelSize = 1
			MOVE	D0,cmpCount(A0)					; cmpCount = 1
			MOVE	D0,cmpSize(A0)					; cmpSize = 1

; set the GDevice's color table to be one bit per pixel

			MOVE.L	pmTable(A0),A0					; get handle to color table
			MOVE.L	(A0),A0							; and point at that puppy
			MOVEQ	#1,D1							; get a useful number
			MOVE.L	D1,(A0)+						; CTSEED := 1
			MOVE.L	D1,(A0)+						; TransIndex := 0, CTSize := 1
			CLR		(A0)+							; entry 0: value := 0
			MOVEQ	#-1,D0							; set entry 0 to white
			MOVE.L	D0,(A0)+						; set R,G
			MOVE	D0,(A0)+						; and B
			SWAP	D1								; D1 = $00010000
			MOVE.L	D1,(A0)+						; entry1: value := 1, R = 0
			CLR.L	(A0)+							; set G, B
			RTS


;________________________________________________________________________________________
;
; Routine:	AddVidDevice 101c
;
; Inputs:	A0	-	pointer to Slot Manager parameter block
;			A1	-	pointer to ioParamBlock
;
; Outputs:	CCR	-	BEQ if successful, BNE if failure
;
; Trashes:	D0-D1
;
; Function:	allocates a GDevice for a video device and installs it in the device list
;________________________________________________________________________________________

AddVidDevice
			MOVEM.L	D1-D2/A0-A3,-(SP)				; save work registers

; scan for end of chain of grafDevices
; in case already opened, check if this refNum already installed

			MOVE	ioRefNum(A1),D1					; get refNum of the opened device
			MOVE.L	DeviceList,D0					; get head of device list
@NextDev	MOVE.L	D0,A2							; save handle to current device
			MOVE.L	(A2),A3							; point to current device
			CMP		GDRefNum(A3),D1					; does the refNum match?
			BEQ.S	@End							; =>yes, already installed (default device)
			MOVE.L	GDNextGD(A3),D0					; get handle of next device in chain
			BNE.S	@NextDev						; there is one, keep looking

; allocate and initialize a grafDevice for this device

			CLR.L	-(SP)							; make room for GrafDevice handle
			MOVE	ioRefNum(A1),-(SP)				; push the device's refNum

			BSR.S	GetDefVidMode					; D0 <- the default video mode
			MOVE	$18(A1), -(SP)
			MOVE.L	D0,-(SP)						; Push it

			_NewGDevice								; allocate a new GrafDevice (in system heap)
			MOVE.L	(A2),A0							; get pointer to device at end of list
			MOVE.L	(SP),GDNextGD(A0)				; save current device at end of list
			MOVE.L	(SP),A0							; get the new device's handle
			MOVE.L	(A0),A0							; point to the new device
			ORI.W	#(1<<screenDevice),GDFlags(A0)	; set flag: ScreenDevice

			MOVE.L	(SP)+,A0						; device already on stack
			BSR		InitDefGamma					; initialize gamma correction for this device

@End		MOVEM.L	(SP)+,D1-D2/A0-A3				; restore all registers
			MOVEQ	#0,D0							; no error
			RTS

			ENDWITH									; {spBlock,seBlock,vpBlock}


*************************************************************************************************
*																								*
*				M A C H I N E / F E A T U R E   S P E C I F I C   R O U T I N E S				*
*																								*
*************************************************************************************************


;________________________________________________________________________________________
;
; Routine:	InitSCC 1066
;
; Inputs:	none
; Outputs:	none
; Trashes:	A0, A1
;
; Function:	resets both channels of the SCC
;________________________________________________________________________________________

InitSCC
		IF forRomulator THEN
			TestInRam	a0							; check if we're in RAM									<SM82>
			bne.s	@dontInitSCC					; -> don't initialize the SCC if so						<SM82>
		ENDIF

		IF hasIopScc THEN
			TestFor	SCCIOPExists					; see if we have an SCC IOP
			bz.b	@NoIOP							; if not, don't try to initialize it
			bsr.l	SCCIOPHwInit					; initialize the IOP hardware registers
@NoIOP												; fall thru -- IOP boots in bypass mode
		ENDIF

			btst.b	#3, ($DD3)
			beq.b	@dontInitSCC

			movea.l	SCCWr,a0						; point to SCC base write address (chan B)
			movea.l	SCCRd,a1						; point to SCC base read address (chan B)
			tst.b	(a1)							; synchronize SCC accesses
			move.b	#9,(a0)							; select write register 9
			move.b	#$C0,(a0)						; hardware reset both channels
@dontInitSCC										;														<SM82>
			rts


;________________________________________________________________________________________
;
; Routine:	InstallDriver 1082
;
; Inputs:	A1	-	pointer to driver name string (pascal)
;			D2	-	driver's resource ID
;
; Outputs:	none
;
; Trashes:	D0-D2, A0-A2
;
; Function:	gets a driver from the ROM, and installs and opens it in the first available
;			slot after entry 48
;________________________________________________________________________________________

InstallDriver
			move.l	a1,a2							; move name ptr to a2 for safe keeping
			bsr.s	GetDetachDRVR					; get and detach resource (d1,d1/a1)
			beq.s	@exit							; exit if no handle

			bsr.s	FirstEntryFree					; get ref num of first free entry (/d0,d1)
			_DrvrInstall							; create dce (d0/d0)
			tst.l	d0								; test for error
			bne.s	@releaseDrvr					; ... exit if error
			
			move.l	UTableBase,a0					; point to utable array
			move.l	(a0,d1),a0						; get handle to dce in a3
			move.l	(a0),a0							; get pointer to dce
			move.l	(a1),dCtlDriver(a0)				; load driver

			move.l	(a1),a1							; get pointer to driver
			move.w	drvrFlags(a1),dCtlFlags(a0)		; copy data to dce
			move.w	drvrDelay(a1),dCtlDelay(a0)
			move.w	drvrEMask(a1),dCtlEMask(a0)
			move.w	drvrMenu(a1),dCtlMenu(a0)

			bclr.b	#dNeedLock,dCtlFlags+1(a0)		; set the handle bit
			cmpi.l	#'only', $4(sp)
			beq.b	@exit

@openDrvr	move.l	a2,a1							; load pointer to driver name
			bra.s	OpenDRVR						; open the driver (a1/)

@releaseDrvr	
			move.l	a1,a0							; move handle to a0
			_DisposHandle							; release the memory
@exit		rts


;________________________________________________________________________________________
;
; Routine:	GetDetachDrvr 10ce, GetDetachRes 10d4
;
; Inputs:	D1	-	resource type (GetDetachRes)
;			D2	-	driver's resource ID
;
; Outputs:	A1	-	handle to resource
;			CCR	-	BEQ if successful, BNE if failure
;
; Trashes:	D0-D2, A0-A2
;
; Function:	gets a driver from the ROM and detaches it
;________________________________________________________________________________________

GetDetachDRVR
			MOVE.L	#'DRVR',D1
GetDetachRes
			MOVE.W	#MapTrue,ROMMapInsert			; make sure we can get it from ROM
			SUBQ.L	#4, SP							; For return address
			MOVE.L	D1, -(SP)						; Resource type
			MOVE.W	D2, -(SP)						; Resource ID
			_GetResource
			MOVE.L	(SP), A1						; Get resource handle to return
			BNE.S @NoDetach							; If not found, don't try to detach it
			_DetachResource
			MOVE.L	A1,D0							; Set result code
			RTS
@NoDetach
			ADDA.L	#4,SP							; recover stack
			MOVEQ	#0,D0							; set error
			RTS										; return


;________________________________________________________________________________________
;
; Routine:	FirstEntryFree 10f2
;
; Inputs:	none
;
; Outputs:	D0	-	driver refNum
;
; Trashes:	none
;
; Function:	finds the first free entry in the unit table
;________________________________________________________________________________________

StartEntry	equ		(48-1)							; this avoids AppleTalk area
		
FirstEntryFree
			move.l	a0,-(SP)						; save a0

@findEntry	move.l	UTableBase,a0					; point to utable array
			move.l	#(StartEntry*4),d0				; start at entry (48-1)
				
@testEntry	addq.l	#4,d0							; increment to next entry
			tst.l	0(a0,d0)						; test entry
			bne.s	@testEntry						; if != 0, next entry
				
@calcRefnum	move.l	d0,d1
			lsr.l	#2,d0							; divide by 4 to get entry number
			addq.l	#1,d0							; add 1 (refnum is -(entry number + 1)
			neg.l	d0								; negate to get reference number				
				
			move.l	(SP)+,a0						; restore a0
			rts


;________________________________________________________________________________________
;
; Routine:	OpenDRVR 1112
;
; Inputs:	A1	-	pointer to driver name string (pascal)
;
; Outputs:	D0	-	driver refNum in high word, Open result in low word
;			CCR	-	BEQ if successful, BNE if failure
;
; Trashes:	A0
;
; Function:	opens a driver
;________________________________________________________________________________________

OpenDRVR	LEA		-ioQElSize(SP),SP				; Allocate IO stack frame
			MOVE.L	SP,A0							; set a0 to point to the pb
			MOVE.L	A1,ioVNPtr(A0)					; load pointer to name
			MOVE.B	#fsCurPerm,ioPermssn(A0)		; set permission (not used)
			_Open

			MOVE.W	ioRefNum(A0),D0					; return ioRefNum (D0.W:HI)
			SWAP	D0								; move ioRefNum HI
			MOVE.W	ioResult(A0),D0					; return result (D0.W:LO)
			LEA		ioQElSize(SP),SP				; Release stack frame
			RTS										; Sucess returned in status


		IF hasEgret THEN
;________________________________________________________________________________________
;
; Routine:	CheckForEgretOrCuda 1132
;
; Inputs:	none
;
; Outputs:	CCR	-	BEQ if there is an Egret/Caboose/Cuda of some sort
;
; Trashes:	D0
;
; Function:	checks if the Egret chip exists
;________________________________________________________________________________________

			EXPORT	CheckForEgretOrCuda				; so others can use this								<T9>
CheckForEgretOrCuda									;														<T2>
			moveq.l	#ProductInfo.ADBMask,d0			; mask for ADB kind										<T2>
			and.l	UnivRomFlags,d0					; isolate the field										<T2>
			subq.l	#ProductInfo.ADBEgret,d0		; see if we have Egret ADB								<T2>
			beq.s	@checkDone						; if we do, go initialize it							<T2>
			moveq.l	#ProductInfo.ClockMask,d0		; mask for Clock kind									<T2>
			and.l	UnivRomFlags,d0					; isolate the field										<T2>
			cmpi.b	#ProductInfo.ClockEgret,d0		; see if we have Egret Clock + PRAM						<T2>
@checkDone	rts										;														<T2>
		ENDIF




;ÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉÉ
;
;	Taken from SCSIMgrInit.a
;
;ÑÑÑ Do PRAM stuff : Bytes 2 & 3 are allocated for SCSI stuff
;
;	ÑÑÑ Byte 2 ÑÑÑ
;  bit	-  def: meaning
;	7	-	0 : If set, disable the SCSIReset on machine reset
;	6	-	1 : unused
;	5	-	0 : unused
;	4	-	0 : unused (on PDM debug, affects Read DMA reads)
;	3	-	1 : validity bit (both must be 1 for bytes 2&3 to be valid, else init them)
;	2	-	1 : \
;	1	-	1 :  Ñ Host ID (i.e. SCSI ID of this Macintosh)
;	0	-	1 : /
;
;	ÑÑÑ Byte 3 ÑÑÑ
;	7	-	0 : unused
;	6	-	1 : unused
;	5	-	0 : unused
;	4	-	0 : unused (on PDM debug, affects Read DMA writes)
;	3	-	1 : validity bit (see above)
;	2	-	0 : \
;	1	-	0 :  Ñ "Internal Drive" ID (i.e. zero generally because nobody changes this)
;	0	-	0 : /
;

SetScsiIdFromPram
; 1148

			subq.l	#2,sp					; make space for PRAM SCSI id					<v1.4>
			move.l	sp,a0					; address of PRAM return buffer

			move.l	#$00020002,d0			; read 2 bytes of PRAM at offset 2	<C613>
			_ReadXPRam						; get the SCSI id
			move.w	(sp),d0					; check high bits for validity		<A324>
			and.w	#$0808,d0				; look at upper bit in lower nibble	<SM15> pdw
			cmp.w	#$0808,d0				; equal to magic pattern?			<C613>
			beq.s	@GotID					; yes, so use those SCSI IDs		<A324>

;--- if invalid, reinitialize values to defaults
@SetID
			move.w	#(($48+7)<<8) + ($48+0),(sp)	; defaults: CPU=7,hd=0	<C613>
			move.l	sp,a0					; address of new PRAM value
			move.l	#$00020002,d0			; write 2 bytes of PRAM to offset 2	<C613>
			_WriteXPRam						; save the IDs in parameter RAM		<C613>
@GotID
			move.w	(sp)+, d0
			
			lsr.w	#8,d0					; get CPU SCSI ID for shift count
			and.w	#$7,d0					; mask all but the ID bit

			moveq.l	#1,d1					; 1 << SCSI id
			lsl.b	d0,d1					; form the SCSI id mask
			move.b	d1,SCSIDrvrs			; clear all SCSI driver flags but our own

			rts




CreateAltiVecBufForEmulator
; 1180
OnePage		equ		$1000

			move.l	#gestaltPowerPCProcessorFeatures, d0
			_Gestalt
			bne.s	@done

			move.l	a0, d0
			and.l	#1<<gestaltPowerPCHasVectorInstructions, d0
			bz.s	@done

			move.l	#OnePage * 2, d0		; allocate 2 pages but only use one
			_NewPtr	,sys,clear
			bne.s	@done

			lea		$68FFF000, a2			; emulator data page

			move.l	a0, d0					; align up to page boundary
			add.l	#OnePage-1, d0
			and.l	#-OnePage, d0

			move.l	d0, $E0(a2)				; save logical ptr
			move.l	#$FE000000, $E8(a2)
			clr.l	$EC(a2)

			move.l	d0, a0
			move.l	#OnePage, a1
			_LockMemory

			bsr.l	GetRealProc
			bmi.s	@done

			move.l	a0, $E4(a2)				; save physical ptr

@done
			rts



			align 16
			end