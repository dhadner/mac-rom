;__________________________________________________________________________________________________
;	File:		GDevice.a
;
;	Contains:	QuickDraw routines that manage GDevices
;
;	Written by:	Various Authors
;
;	Copyright:	© 1981-1993 by Apple Computer, Inc., all rights reserved.
;
;	Change History (most recent first):
;
;	   <SM5>	10-19-93	jmp		Changed NewGDevice so it more intelligently handles mono-only
;									devices.
;	   <SM4>	  4/8/93	IH		Add some comments on Display Manager assumptions about
;									InitGDevice to InitGDevice header.
;	   <SM3>	  2/4/93	CSS		Update from Horror:
;		<H2>	 7/10/92	SWC		Made a change to GetDevPixMap to fix a problem with fixed
;									devices. It was generating a new ctSeed unconditionally, which
;									caused problems with the IconUtilities package since the Palette
;									Manager would say that the tolerance between the device's and
;									system CLUTs wasn't close enough to draw a multi-bit icon.
;	   <SM2>	 6/11/92	stb		<sm 6/9/92>stb Synched with QDciPatchROM.a, added comments to
;									DisposGDevice and InitGDevice.
;		 <8>	 7/24/90	gbm		get rid of stupid branch
;		 <7>	 2/20/90	BAL		When disposing the LastTxGDevice, reset it to the MainDevice.
;		 <6>	  2/1/90	DAF		Add AllocCrsr before ShowCursor in CheckDevices (called from
;									InitGraf). Changed ShieldCursor to HideCursor in InitGDevice.
;									This is consistent with the CheckDevicesINIT.a.
;		 <5>	 1/29/90	DVB		Dont walk nonexistant portlist
;		 <4>	 1/17/90	DVB		Touch-up to InitGDevice
;		 <3>	 1/12/90	DVB		More InitGDevice
;		 <2>	  1/8/90	DVB		Make InitGDevice safer and smarter about changing baseAddr's
;	   <2.6>	 9/25/89	BAL		Defered InitGDevices paletteMgr notify until after the GDRect is
;									valid.
;	  <•2.5>	 7/14/89	BAL		For Aurora: Final CQD
;	   <2.4>	 7/13/89	DAF		FOR AURORA BUILD - Two fixes: 1) corrected startup gamma tables
;									from scrn resource in CheckDevices; 2) rewrote fixed device
;									color table handling in GetDevPixMap (fixes E-Machines Big
;									Picture)
;	   <2.3>	  7/6/89	GGD		Changed the JSR OPENPIXMAP to a BSR.L so that it can reach when
;									alignment is turned on.
;	   <2.2>	 6/30/89	BAL		Changed source to use mainScreen instead of mainScrn
;	   <2.1>	 6/12/89	BAL		Altered InitGDevice to not request grayscale versions for 1 and
;									2 bit modes.
;	   <2.0>	 6/10/89	CEL		Moved Private.a QuickDraw Equates into proper QuickDraw private
;									file (colorequ.a), got rid of QuickDraw nFiles dependencies and
;									fixed up necessary files…
;	   <1.9>	 5/30/89	DAF		Fixed gdpMap rect offsets when then scrn resource is bad
;	  <•1.8>	 5/29/89	BAL		Blasting in 32-Bit QuickDraw version 1.0 Final
;	  <•1.7>	 4/12/89	BAL		Blasting in 32-Bit QuickDraw 1.0B1
;				  4/5/89	DAF		Added more validity checking of scrn resource in CheckDevices
;									(compares scrnRects,too). If scrn resource is invalid, then
;									offset all inactive screens from (0,0) to help out people who
;									forget to check scrnActive.
;				  4/3/89	DAF		Updated InitGDevice to set driver luminence mapping even if
;									pixel depth doesn't change.
;				 3/26/89	DAF		Added linear gamma support from scrn resource; reordered
;									CheckDevices; integrated CheckGray into CheckDevices; updated
;									SetGray/getCTable support to the new world; plugged InitGDevice
;									into Palette Manager; corrected fixed CLUT support in
;									GetDevPixmap.
;				12/11/88	BAL		Altered getDevPixMap to set high bit of pmVersion for 32 bit
;									base addresses.
;	  <C887>	  9/9/87	GWN		32-bit mode fix for Slot manager. Use DCE to get device base.
;				 5/27/87	EHB		Roll patch into CheckDevices to make sure color/gray is set.
;	  <C741>	  2/2/87	JTC		Change to new, word-length <cat><id><sw><hw> constants.
;	  <C742>	  2/2/87	GWN		Changed read of video parameters.
;	  <C720>	 1/29/87	GWN		Cleared spExtDev field where neccessary.
;	  <C100>	  8/1/86	DAF		InitGDevice to handle uninitialized theGDevice.
;				 7/29/86	DAF		Modified for color manager
;				  5/8/86	EHB		New Today
;
;	To Do:
;__________________________________________________________________________________________________

;EASE$$$ READ ONLY COPY of file 'gdevice.a'
; 2.6	BAL 09/25/1989 Defered InitGDevices paletteMgr notify until after the GDRect is valid.
;•2.5	BAL 07/14/1989 For Aurora: Final CQD
; 2.4	DAF 07/13/1989 FOR AURORA BUILD - Two fixes: 1) corrected startup gamma
;		tables from scrn resource in CheckDevices; 2) rewrote fixed device
;		color table handling in GetDevPixMap (fixes E-Machines Big Picture)
; 2.3	GGD 07/06/1989  Changed the JSR OPENPIXMAP to a BSR.L so that it can reach when alignment
;		is turned on.
; 2.2	BAL 06/30/1989 Changed source to use mainScreen instead of mainScrn
; 2.1	BAL 06/12/1989 Altered InitGDevice to not request grayscale versions for 1 and 2 bit modes.
; 2.0	CEL 06/10/1989 Moved Private.a QuickDraw Equates into proper QuickDraw
;		private file (colorequ.a), got rid of QuickDraw nFiles dependencies
;		and fixed up necessary files…
; 1.9	DAF 05/30/1989 Fixed gdpMap rect offsets when then scrn resource is bad
;•1.8	BAL 05/29/1989 Blasting in 32-Bit QuickDraw version 1.0 Final
;•1.7	BAL 04/12/1989 Blasting in 32-Bit QuickDraw 1.0B1
; File GDevice.a
;
; Copyright Apple Computer, Inc.  1981-1986
; All Rights Reserved
;
;

		BLANKS	ON
		STRING	ASIS

		MACHINE	MC68020

;------------------------------------------------------
;
;  QuickDraw Routines to maintain the current grafDevice.
;

; MODIFICATION HISTORY
;
;  8May86  EHB	New Today
; 29Jul86  DAF	Modified for color manager
; <C100/01Aug86> DAF InitGDevice to handle uninitialized theGDevice.
; <C720/29Jan87> GWN Cleared spExtDev field where neccessary.
; <C741/02Feb87> JTC Change to new, word-length <cat><id><sw><hw> constants.
; <C742/02Feb87> GWN Changed read of video parameters.
; <C887 09Sep87> GWN 32-bit mode fix for Slot manager. Use DCE to get device base.
;
;----------------------------  Macintosh II ROMs  -----------------------------
;
; 	27May87	EHB Roll patch into CheckDevices to make sure color/gray is set.
;
;----------------------------  32-bit QuickDraw  ------------------------------
;
; 	11Dec88	BAL Altered getDevPixMap to set high bit of pmVersion for 32 bit base addresses.
;	26Mar89	DAF	Added linear gamma support from scrn resource; reordered CheckDevices;
;				integrated CheckGray into CheckDevices; updated SetGray/getCTable support
;				to the new world; plugged InitGDevice into Palette Manager; corrected
;				fixed CLUT support in GetDevPixmap.
;	3Apr89	DAF	Updated InitGDevice to set driver luminence mapping even if pixel depth
;				doesn't change.
;	5Apr89	DAF	Added more validity checking of scrn resource in CheckDevices (compares
;				scrnRects,too).  If scrn resource is invalid, then offset all inactive
;				screens from (0,0) to help out people who forget to check scrnActive.


NewGDevice 	PROC  	EXPORT
			IMPORT 	INITGDEVICE,OPENPIXMAP,SetGDevice,DisposGDHandles
;-------------------------------------------------------------
;
;  FUNCTION NewGDevice (refNum: INTEGER; mode: LONGINT) : GDHandle;
;
;  	Allocate a new GDevice and all its handles, then call InitGDevice
;	to initialize it for the specified device in the specified mode.
;   The grafDevice and its pixMap are always locked down.
;
;   If a memory request is unsuccessful, then a NIL handle is returned
;
;	NOTE:  Assumes that the driver has already been opened (it has a
; 	REFNUM and a DCE).
;
PARAMSIZE	EQU 	6						; total bytes of parameters
RESULT		EQU 	PARAMSIZE+8 			; LONG, GrafDevice
REFNUM		EQU 	RESULT-2				; WORD, Driver reference number
MODE		EQU 	REFNUM-4				; LONG, Mode for video card

		LINK	A6,#0						; no locals
		MOVEM.L	A2/A3,-(SP)					; preserve work registers
		CLR.L	RESULT(A6)					; indicate failure

		MOVE.L	theZone,-(SP)				; save the current heap zone
		MOVE.L	sysZone,theZone				; and get the system heap

		MOVEQ	#GDRec,D0					; get size of graf device record
		_RESRVMEM							; reserve space for it down low
		BNE		NOMEM						; => couldn't get it
		MOVEQ	#GDRec,D0					; get size of graf device record
		_NEWHANDLE	,CLEAR					; allocate the handle
		_HLOCK								; and lock it
		MOVE.L	A0,A2						; A2 = graf device handle
		MOVE.L	(A2),A3						; A3 = graf device pointer

		MOVEQ	#2,D0						; initial size of inverse table
		_NEWHANDLE ,CLEAR					; get a handle for the inverse table
											; allocated in system heap
		BNE		NOMEM						; => couldn't get it
		MOVE.L	A0,GDITable(A3)				; save handle to inverse table

		MOVEQ	#2,D0						; initial size of expanded cursor data
		_NEWHANDLE ,CLEAR					; get a handle for expanded cursor data
											; allocated in system heap
		BNE.S	NOMEM						; => couldn't get it
		MOVE.L	A0,GDCCXDATA(A3)			; save handle to expanded cursor data

		MOVEQ	#2,D0						; initial size of expanded cursor mask
		_NEWHANDLE ,CLEAR					; get a handle for the expanded cursor mask
											; allocated in system heap
		BNE.S	NOMEM						; => couldn't get it
		MOVE.L	A0,GDCCXMASK(A3)			; save handle to expanded cursor mask

		MOVEQ	#CCSaveRec,D0				; get size needed by openPixMap
		_ResrvMem							; reserve space down low
		BNE.S	NOMEM						; => couldn't get it
		CLR.L	-(SP)						; make room for function result
		BSR.L	OPENPIXMAP					; get an uninitialize pixMap in sysHeap	<2.3>
		MOVE.L	(SP),GDPMap(A3)				; save pixel Map
		MOVE.L	(SP)+,A0					; get handle to pixMap
		_HLock								; and lock it down

		MOVE.L	MODE(A6),D0					; get the mode							<C710>
		CMP.L	#-1,D0						; if mode = -1, then don't init			<C769>
		beq.s	Done						; => go home							<C769>

		Bsr		TestForGray					; is it monochrome only?
		Bne.s	@Mono						; => yes, leave GDevice mono
		BSET	#GDDevType,GDFlags+1(A3)	; else default to color

@Mono	MOVE.W	REFNUM(A6),-(SP)			; pass device to initialize
		MOVE.L	MODE(A6),-(SP)				; pass mode to initialize
		MOVE.L	A2,-(SP)					; and pass gDevice handle
		JSR		([$16B8])					; initialize the device port

DONE	MOVE.L	(SP)+,theZone				; restore the zone
		MOVE.L	A2,RESULT(A6)				; return graf device handle
		MOVEM.L	(SP)+,A2/A3					; restore work register
		UNLINK	PARAMSIZE,'NEWGDEVI'

NOMEM	MOVE.L	A2,-(SP)					; push grafDevice
		JSR		DisposGDHandles				; and dispose of its handles
		BRA.S	DONE						; => and return

;
;	Ever since the first Edition of Cards & Drivers, the video driver call SetGray has been
;	documented.  This routine takes a byte (0=color, non-zero=gray), and tells the video
;	driver to put itself into luminence mapping mode (gray) or not.  This call has been
;	defined as 'optional,' so some video drivers may exclude it.  Nevertheless, by using
;	this call we can make a fairly intelligent guess as to whether to leave a multibit
;	GDevice mono or not.  Indeed, if we attempt to call SetGray(0), and we get back a non-zero,
;	value, then we should leave the GDevice mono.  All Apple video drivers have done this with
;	their monochrome-only displays.
;
		
		With	VDPageInfo
TestForGray
@SaveEm	Reg		A0-A1/D0					; 	
		Movem.l	@SaveEm,-(Sp)				; Borrow a few registers for a while.
		Suba.w	#ioQElSize,Sp				; Allocate an I/O param block on the stack.
		Movea.l	Sp,A0						; Point to it.
		Subq	#4,Sp						; Allocate a CS param block on the stack.
		Movea.l	Sp,A1						; Point to it.
		Clr.b	csMode(A1)					; Say that we want mapping off.
											; Set up for the Control call:
		Move.w	RefNum(A6),ioRefNum(A0)		;	ioRefNum, 
		Move.w	#cscSetGray,csCode(A0)		;	csCode,
		Move.l	A1,csParam(A0)				;	csParam.
		_Control ,Immed						; SetGray.
		Bne.s	@Error						; If failed, then just leave.
		Tst.b	csMode(A1)					; Otherwise, see if we got back what we set.
		Bra.s	@Done						;

@Error	Moveq	#0,D0						; Just set up to leave things alone.
@Done	Adda.w	#ioQElSize+4,Sp				; Restore the stack space we used.
		Movem.l	(Sp)+,@SaveEm				; Restore the regs we borrowed.		
		Rts									; Vamoose.
		Endwith

DisposGDevice 	PROC	EXPORT
				EXPORT	DisposGDHandles
;-------------------------------------------------------------
;
;  PROCEDURE DisposGDevice (GDH: GDHandle);
;
;  disposes of the gDevice record and its handles
;
		MOVE.L	(SP)+,A1					; get return address
		MOVE.L	(SP),-(SP)					; push the grafDevice
		BSR.S	DisposGDHandles				; and dispose of its handles

; as seen in QDciPatchROM.a													<sm 6/9/92>stb
		MOVE.L	(SP)+,A0					; get the grafDevice
		cmp.l	LastTxGDevice,A0			; are we disposing it?	<BAL 20Feb90>
		bne.s	@noProb						; no, continue			<BAL 20Feb90>
		move.l	MainDevice,LastTxGDevice	; yes, reset it.		<BAL 20Feb90>
@noProb										;						<BAL 20Feb90>

		_DisposHandle						; dispose of it

		JMP		(A1)						; and exit


DisposGDHandles

		MOVE.L	A1,-(SP)					; save A1
		MOVE.L	8(SP),A1					; get handle to GDevice
		MOVE.L  (A1),A1						; point to GDevice
		MOVE.L	GDPMap(A1),-(SP)			; push pixMap handle
		MOVE.L	GDITable(A1),D0				; get inverse table
		BEQ.S	@0							; => none
		MOVE.L	D0,A0						; else get it
		_DisposHandle						; and dispose it
@0		MOVE.L	GDCCXData(A1),D0			; get cursor data
		BEQ.S	@1							; => none
		MOVE.L	D0,A0						; else get it
		_DisposHandle						; and dispose it
@1		MOVE.L	GDCCXMask(A1),D0			; get cursor mask
		BEQ.S	@2							; => none
		MOVE.L	D0,A0						; else get it
		_DisposHandle						; and dispose it
@2		MOVE.L	(SP)+,D0					; get pixMap handle
		BEQ.S	@3							; => it's not there
		MOVE.L	D0,-(SP)					; else push it again
		_DisposPixMap						; and dispose of the pixMap
@3		MOVE.L	(SP)+,A1					; restore A1
		MOVE.L	(SP)+,(SP)					; strip parameter
		RTS									; and return

; as seen in QDciPatchROM.a verbatim										<sm 6/9/92>stb

InitGDevice PROC  EXPORT

			WITH		VDPageInfo			;<1.1>

			IMPORT OneBitData,GetDevPixMap
;-------------------------------------------------------------
;
;	PROCEDURE InitGDevice (refNum: INTEGER; mode: LONGINT; GDH: GDHandle);
;
;	Initialize the specified device to the specified mode.  The GDevice
;	data is placed into the provided handle.
;
;   If mode = -1 then the driver is not called.  It is assumed that the pixmap
;   has been set up before InitGDevice is called.
;
;	Now has support for GDevices with baseAddrs that change across depths
;	(Trident card) in a MultiFinder-friendly way.
;
; CAUTION: this routine is used during ROM boot; various Macintosh functions
; may not yet be available! <dvb - found out the hard way>
;
; CAUTION:  Display Manager counts on the way some of the flags are used.  Do
;	not change without testing the resolution flipping in display manager.  
;
;	Are there patch implications (especially for the mainScreen flag) that
;	mean I should handle this in a different way?  Are there patches that count
;	on these flags?  Here are the flags Display Manager changes:
;
;	ramInit -- Display Manager clears ramInit bit so rect will be fetched from the video card.
;	gdMode -- Display Manager clears.  When switching to a different resolution the enabled 
;			functional sResource has changed, however the spID is frequently the same for the
;			same depth.  By clearing gdMode, we know that InitGDevice will not bail because
;			it thinks the modes are the same.
;	mainScreen -- Display Manager clears mainScreen bit because it does not want InitGDevice to
;			mess with the ports.  Display Manager has more things to do to the ports (at a higher
;			level) than it would be appropriate to do here.  Some day we may roll in here, but
;			for now I clear this bit to make sure InitGDevice does not try to fix ports.
;
IGDVars		RECORD	{A6Link},DECREMENT
result		DS.B	0						; no result
REFNUM		DS.B	2
MODE		DS.B	4						; LONG, mode for video card
GDH			DS.B	4						; LONG, handle to devPort
return		DS.B	4						; the return address
A6Link		DS.B	4						; our link

IOPBlk		DS.B	IOVQElSize				; [64] parameter blk for I/O calls
VidParms	DS.B	12						; [12] size of mode params
GDHState	DS.B	2						; [word] lock state of GDH
GDPState	DS.B	2						; [word] lock state of GDP
SaveDevice	DS.B	4						; [long] saved device handle

oldBaseAddr	DS.B	4						; old base address, for later comparison
oldPort		DS.B	4						; thePort, before we got here
oldColor	DS.B	8						; a colorSpec used to reinstantiate fg/bk

			DS.B	356

VARSIZE		DS.B	0						; size of locals
			ENDR

		WITH	IGDVars

		LINK	A6,#VARSIZE					; allocate stack frame
		MOVEM.L	D3/A2-A4,-(SP)				; save off work registers

		MOVE.L	ExpandMem,A0
		MOVE.L	$1FC(A0),A1
		TST.B	$B5(A1)
		BNE.S	@true
		CLR		$276(A0)
@true

		MOVE.L	GDH(A6),A0					; get the gDevice handle
		_HGetState							; get the current lock state
		MOVE	D0,GDHState(A6)				; save the state
		_HLOCK								; and lock down the gDevice
		MOVE.L	(A0),A2						; get pointer to gDevice record
		MOVE.L	GDPMap(A2),A0				; get handle to pixMap
		MOVE.L	(A0),A1						 ; A1->pixmap
		MOVE.L	baseAddr(A1),oldBaseAddr(A6) ; save the base address, for later portfixing
		_HGetState							 ; get the current lock state of the pixmap
		MOVE	D0,GDPState(A6)				; save the state
		_HLOCK								; lock it down
		MOVE.L	(A0),A3						; keep pointer in A3
		MOVE.L	theGDevice,SaveDevice(A6)	; save theGDevice

		TST.B	QDExist						; qd around?
		BNE.S	@noShield					; no, don't shield cursor
		BTST	#screenDevice,gdFlags(A2)		; is it screen (check hi byte with #>8)
		BEQ.S	@noShield
		JSR		([$F48])

@noShield

; initialize the GDevice's mode and refnum

		SF.B	-$6E(A6)
		MOVE	REFNUM(A6),GDRefNum(A2) 	; set up RefNum
		MOVE.L	MODE(A6),D0					; get the mode
		CMP.L	MinusOne,D0					; is the mode -1?
		BEQ		ModeOK						; if so, then don't call the driver

; set up the driver parameter block in case we need to use it

		LEA		IOPBlk(A6),A0				; point to parameter block
		CLR.L	ioCompletion(A0)			; no completion routine
		CLR.W	ioVRefNum(A0)				; no volRefNum
		MOVE	RefNum(A6),ioRefNum(A0)		; set device's refnum
		LEA		VidParms(A6),A1				; point to params for GetMode
		MOVE.L	A1,csParam(A0)				; point to param list

		CMP.L	GDMode(A2),D0				; has the mode changed?
		BEQ.S	GrayOrColor					; => no, so don't set depth
		ST.B	-$6E(A6)
		MOVE.L	D0,GDMode(A2)				; set up mode

; setup the gDevice fields for the new screen depth

		CLR		GDCCDepth(A2)				; invalidate cursor depth			<C837>

		MOVEM.L	A0/A1,-(SP)					; save these regs
		MOVE	REFNUM(A6),-(SP)			; push refnum
		MOVE.L	MODE(A6),-(SP)				; push mode
		MOVE.L	GDPMap(A2),-(SP)			; pixMap handle
		PEA		GDType(A2)					; point to device type
		JSR		GetDevPixMap				; read in pixMap from device
		MOVEM.L	(SP)+,A0/A1					; restore them

; first, set the mode (A0 points to IOPB, A1 to control parameter block)

		MOVE	#2,csCode(A0)				; csc_GetMode

		MOVE.L	mode(A6),D0					; get the mode
		MOVE	D0,csMode(A1)				; set desired mode
		CLR		csPage(A1)					; set page 1
		CLR.L	csData(A1)					; no additional data

		_Control ,IMMED						; SetMode(Mode,Page,Data);

; then gray the screen

		MOVE    #5,csCode(A0)               ; csc_GrayPage
		_Control ,IMMED                     ; paint current page gray

; set the device to color or monochrome, according to GDFlags

GrayOrColor
		MOVE	GDFlags(A2),D0				; get flags word
		NOT		D0							; flip all bits
		AND		#1,D0						; clear all but low bit
		MOVE.B	D0,csMode(A1)				; csMode = color/gray scale
		MOVE	#6,csCode(A0)				; csc_SetGray
		_Control ,IMMED                     ; set color or monochrome

; if the device has a color table, set the device's color table

		CMP		#ClutType,GDType(A2)		; is there a lookup table?
		BNE.S	NoTbl						; =>no, don't set one

		MOVE.L	pmTable(A3),A0				; get handle to color table
		_HLock								; lock down the color table

;+++		LEA		VidParms(A6),A1				; point to params for SetEntries
		MOVE.L	(A0),A0						; get ctabPtr							<DAF>
		CLR.W	csStart(A1)					; start at zero, use sequence mode		<DAF>
		MOVE.W	ctSize(A0),csCount(A1)		; for the length of the table			<DAF>
		LEA		ctTable(A0),A0				; get pointer to colorspecs				<DAF>
		MOVE.L	A0,csTable(A1)				; color table pointer is first param	<DAF>

		LEA		IOPBlk(A6),A0				; point to parameter block
		MOVE.W	#3,csCode(A0)				; csc_SetEntries
		MOVE.L	A1,csParam(A0)				; move addr of parms into block

		_Control ,IMMED						; SetEntries(ColorTable);

		MOVE.L	pmTable(A3),A0				; get handle to color table
		_HUnlock							; unlock the color table
NoTbl

; if CLUT or fixed color table, build inverse table

		CMP		#DirectType,GDType(A2)		; should there be an inverse table?
		BEQ.S	ModeOK						; =>no inverse table

		MOVE.L	pmTable(A3),-(SP)			; push color table handle
		MOVE.L	GDITable(A2),-(SP)			; push inverse table handle
		MOVEQ	#4,D0						; make 4-4-4 inverse tables
		MOVE	D0,GDResPref(A2)			; save in GDevice
		MOVE	D0,-(SP)					; and push res
		JSR		([$16E4])					; and generate table


ModeOK
		MOVE.L	([$2B6],$1FC),A0
		TST.B	$B5(A0)
		BEQ		@L13
		MOVE	$14(A2),D0
		BTST.L	#$D,D0
		BEQ		@L13
		BTST.L	#$A,D0
		BEQ		@L13
		TST		(A2)
		BEQ		@L13
		TST.B	-$6E(A6)
		BEQ		@L13
		MOVE.L	$22(A2),-$6C(A6)
		MOVE.L	$26(A2),-$68(A6)
		TST.B	(QDExist)
		BNE		@L9
		MOVE.L	A5,-$7A(A6)
		LEA.L	-$7E(A6),A5
		MOVE.L	$6(A3),$22(A2)
		MOVE.L	$A(A3),$26(A2)
		MOVE.L	(ScrnBase),-$1BC(A6)
		MOVE.L	-$58(A6),D1
		CMP.L	(ScrnBase),D1
		BNE.S	@L0
		MOVE	$14(A2),D0
		BTST.L	#$B,D0
		BEQ		@L0
		MOVE.L	(A3),(ScrnBase)
@L0		PEA.L	-$82(A6)
		_InitGraf
		PEA.L	-$1B8(A6)
		_OpenPort
		MOVE.L	D2,-(SP)
		MOVEQ.L	#$0,D1
		MOVEQ.L	#$1,D2
		MOVE.L	(DeviceList),D0
@L1		BEQ.S	@L5
		MOVE.L	D0,A0
		CMPA.L	$8(A6),A0
		MOVE.L	(A0),A0
		BNE.S	@L2
		BSET.B	#$7,$14(A0)
		BNE.S	@L4
		BRA.S	@L3
@L2		BTST.B	#$7,$14(A0)
		BEQ.S	@L4
		BCLR.B	#$7,$14(A0)
@L3		OR		D2,D1
@L4		LSL		#$1,D2
		MOVE.L	$1E(A0),D0
		BRA.S	@L1
@L5		MOVE.L	(SP)+,D2
		MOVE	D1,-(SP)
		SUBQ.L	#$4,SP
		_NewRgn
		MOVE.L	(SP),-(SP)
		MOVE.L	(SP),-(SP)
		PEA.L	$6(A3)
		_RectRgn
		LEA.L	-$1B8(A6),A0
		MOVE.L	$18(A0),-(SP)
		MOVE.L	(SP),-(SP)
		_UnionRgn
		_DisposRgn
		MOVE	$C(A3),D0
		SUB		$8(A3),D0
		MOVE	-$66(A6),D1
		SUB		-$6A(A6),D1
		SUB		D1,D0
		ASR		#$1,D0
		MOVE	D0,-$1C6(A6)
		MOVE	$A(A3),D0
		SUB		$6(A3),D0
		MOVE	-$68(A6),D1
		SUB		-$6C(A6),D1
		SUB		D1,D0
		ASR		#$1,D0
		MOVE	D0,-$1C8(A6)
		MOVE	$8(A3),D0
		ADD		-$1C6(A6),D0
		MOVE.L	$6(A3),-$76(A6)
		MOVE	$A(A3),-$72(A6)
		MOVE	D0,-$70(A6)
		PEA.L	-$76(A6)
		MOVE.L	(A5),A1
		PEA.L	-$10(A1)
		_FillRect
		MOVE	$6(A3),D0
		ADD		-$1C8(A6),D0
		MOVE	$C(A3),-$70(A6)
		MOVE	D0,-$72(A6)
		PEA.L	-$76(A6)
		MOVE.L	(A5),A1
		PEA.L	-$10(A1)
		_FillRect
		MOVE	$A(A3),D0
		SUB		-$1C8(A6),D0
		MOVE.L	$A(A3),-$72(A6)
		MOVE	$8(A3),-$74(A6)
		MOVE	D0,-$76(A6)
		PEA.L	-$76(A6)
		MOVE.L	(A5),A1
		PEA.L	-$10(A1)
		_FillRect
		MOVE	$C(A3),D0
		SUB		-$1C6(A6),D0
		MOVE	$6(A3),-$76(A6)
		MOVE	D0,-$74(A6)
		PEA.L	-$76(A6)
		MOVE.L	(A5),A1
		PEA.L	-$10(A1)
		_FillRect
		MOVE	(SP)+,D1
		BEQ.S	@L8
		MOVE.L	(DeviceList),D0
@L6		BEQ.S	@L8
		MOVE.L	D0,A0
		MOVE.L	(A0),A0
		LSR		#$1,D1
		BCC.S	@L7
		BSET.B	#$7,$14(A0)
		TST		D1
		BEQ.S	@L8
@L7		MOVE.L	$1E(A0),D0
		BRA.S	@L6
@L8		PEA.L	-$1B8(A6)
		_ClosePort
		MOVE.L	-$1BC(A6),(ScrnBase)
		MOVE.L	-$6C(A6),$22(A2)
		MOVE.L	-$68(A6),$26(A2)
		MOVE.L	-$7A(A6),A5
@L9		MOVE	D2,-(SP)
		MOVE.L	$16(A2),A0
		MOVE.L	(A0),A0
		MOVE	$4(A0),D0
		ANDI	#$7FFF,D0
		MOVE	$A(A0),D1
		SUB		$6(A0),D1
		ADD		-$6C(A6),D1
		SUB		-$68(A6),D1
		ASR		#$1,D1
		MULU	D1,D0
		MOVE	$C(A0),D1
		SUB		$8(A0),D1
		ADD		-$6A(A6),D1
		SUB		-$66(A6),D1
		ASR		#$1,D1
		MOVE	$20(A0),D2
		CMPI	#$8,D2
		BGT.S	@L11
		BEQ.S	@L12
@L10	ASR		#$1,D1
		ASL		#$1,D2
		CMPI	#$8,D2
		BLT.S	@L10
		BRA.S	@L12
@L11	ASR		#$3,D2
		MULU	D2,D1
@L12	EXT.L	D1
		ADD.L	D1,D0
		ADD.L	D0,(A0)
		MOVE	(SP)+,D2
@L13	LEA.L	$6(A3),A0
		LEA.L	$22(A2),A1
		MOVE	$14(A2),D0
		BTST.L	#$A,D0
		BEQ.S	@L14
		EXG.L	A0,A1
@L14	MOVE.L	(A0)+,(A1)+
		MOVE.L	(A0)+,(A1)+
		TST.B	(QDExist)
		BNE		@L20
		MOVE.L	(PortList),D1
		BEQ		@L20
		ADDQ.L	#$1,D1
		BEQ		@L20
		BTST.L	#$B,D0
		BEQ		@L19
		PEA.L	-$5C(A6)
		_GetPort
		MOVE.L	(MainDevice),(TheGDevice)
		MOVE.L	(PortList),A4
		MOVE.L	(A4),A4
		MOVE	(A4),D3
		BRA.S	@L17
@L15	MOVE.L	(PortList),A4
		MOVE.L	(A4),A4
		MOVE.L	$2(A4,D3.W*4),A4
		MOVE.L	A4,-(SP)
		_SetPort
		MOVE.L	-$58(A6),D1
		BTST.B	#$7,$6(A4)
		BEQ.S	@L16
		MOVE.L	$2(A4),A4
		MOVE.L	(A4),A4
		CMP.L	(A4),D1
		BNE.S	@L17
		MOVE.L	(A3),(A4)
		MOVE	$4(A3),$4(A4)
		MOVE.L	$1E(A3),$1E(A4)
		MOVE.L	$22(A3),$22(A4)
		MOVE.L	$26(A3),$26(A4)
		PEA.L	-$64(A6)
		MOVE.L	(SP),-(SP)
		MOVE.L	(SP),-(SP)
		MOVE.L	(SP),-(SP)
		_SaveFore
		_RestoreFore
		_SaveBack
		_RestoreBack
		BRA.S	@L17
@L16	CMP.L	$2(A4),D1
		BNE.S	@L17
		MOVE.L	(A3),$2(A4)
		MOVE	$4(A3),D1
		ANDI	#$7FFF,D1
		MOVE	D1,$6(A4)
@L17	DBF		D3,@L15
		MOVE.L	-$5C(A6),-(SP)
		_SetPort
		MOVE.L	-$58(A6),D1
		CMP.L	(ScrnBase),D1
		BNE.S	@L18
		MOVE.L	(A3),(ScrnBase)
@L18	MOVE.L	-$58(A6),D1
		MOVE.L	(A5),A0
		CMP.L	-$7A(A0),D1
		BNE.S	@L19
		MOVE.L	(A3),-$7A(A0)
@L19	BTST.B	#$D,$14(A2)
		BEQ.S	@L20
		_AllocCursor
		_ShowCursor
@L20	BSR.S	NewFunc
		MOVE.L	(ExpandMem),A0
		MOVE	D0,$276(A0)

;
; notify the Palette Manager that the mode has changed
;
											; <2.6> moved after GDRect has been adjusted <2.6>
		CMP.L	#-1,PMgrHandle				; has the Palette Mgr been initialized?
		BEQ.S	@noPMgr						; nope, so skip this
		MOVE.L	GDH(A6),-(SP)				; push the device handle
		_RestoreDeviceClut					; call the Palette Manager Unhook device vector
@noPMgr

		MOVE.L	SaveDevice(A6),theGDevice	; restore theGDevice
		MOVE.L	GDPMap(A2),A0				; get pixMap handle
		MOVE	GDPState(A6),D0				; get the lock state
		_HSetState							; restore prior state
		MOVE.L	GDH(A6),A0					; get the gDevice handle
		MOVE	GDHState(A6),D0				; get the lock state
		_HSetState							; restore prior state

		MOVEM.L	(SP)+,D3/A2-A4					; restore work registers
		UNLINK	result-return-4,'INITGDEV'


NewFunc
			MOVE.L	(TheGDevice),D0
			BEQ		@L32
			MOVE.L	(MainDevice),D1
			CMP.L	D0,D0
			BNE.S	@L22
			MOVE.L	(DeviceList),D0
			BEQ.S	@L32
@L22		MOVE.L	D0,A0
			MOVE.L	(A0),A0
			MOVE.L	$1E(A0),D1
			BEQ.S	@L32
@L23		MOVE.L	D1,A1
			MOVE.L	(A1),A1
			MOVE.L	$22(A1),D0
			CMP		$24(A0),D0
			BGT.S	@L27
			BLT.S	@L24
			SWAP	D0
			CMP		$22(A0),D0
			BGT.S	@L28
			BLT.S	@L25
			MOVE.L	$26(A1),D0
			CMP		$28(A0),D0
			BLT.S	@L29
			BGT.S	@L26
			BRA.S	@L30
@L24		SWAP	D0
			CMP		$22(A0),D0
			BGT.S	@L31
@L25		MOVE.L	$26(A1),D0
			CMP		$28(A0),D0
			BLT.S	@L31
@L26		SWAP	D0
			CMP		$26(A0),D0
			BLT.S	@L31
			BRA.S	@L30
@L27		SWAP	D0
			CMP		$22(A0),D0
			BLT.S	@L31
@L28		MOVE.L	$26(A1),D0
			CMP		$28(A0),D0
			BGT.S	@L31
@L29		SWAP	D0
			CMP		$26(A0),D0
			BGT.S	@L31
@L30		MOVEQ.L	#$1,D0
			RTS
@L31		MOVE.L	$1E(A1),D1
			BNE.S	@L23
			MOVE.L	$1E(A0),D0
			BNE.S	@L22
@L32		MOVEQ.L	#$0,D0
			RTS


GetDevPixMap	PROC	EXPORT
				IMPORT	CopyHandle, GetCTSeed, RSetHSize
;----------------------------------------------------------------
;
; PROCEDURE	GetDevPixMap(refNum: INTEGER; mode: LONGINT; PMH: PixMapHandle;VAR DevType:INTEGER);
;
; Calls the slot Manager to fill out the pixMap with info from the specified
; mode of the specified device.  The device need not be configured to that
; mode.
;
; GetDevPixMap is called by InitGDevice.
;
;----------------------------------------------------------------

PARAMSIZE	EQU 	14						; total bytes of parameters
REFNUM		EQU 	PARAMSIZE+8-2			; WORD, Driver reference number
MODE		EQU 	REFNUM-4				; LONG, Mode for video card
PMH			EQU 	MODE-4 					; LONG, PixMap Handle
DEVTYPE		EQU		PMH-4					; LONG, VAR DevType

MYBLOCK		EQU		-spBlock.SPBLOCKSIZE	; allocate room for parameter block	<Cxxx>
PMHState	EQU		MyBlock-2				; save pixMap lockState
VARSIZE		EQU		PMHState-$9A			; size of locals

	WITH	spBlock,vpBlock					;<C742>

			LINK	A6,#VARSIZE					; allocate stack frame
			MOVEM.L	D3-D5/A2-A4,-(SP)			; preserve work registers

; lock down the pixMap and get pointer in A2

			CLR.B	-$D3(A6)
			MOVE.L	PMH(A6),A0					; get handle to pixMap
			_HGetState							; get the current state
			MOVE	D0,PMHState(A6)				; save current state
			_HLock								; lock it down
			MOVE.L	(A0),A2						; get pointer in A2

; look in the unit table for the specified device

			MOVE	REFNUM(A6),D0				; get the refNum
			NOT		D0							; refNum -> unitnum
			ASL		#2,D0						; get offset in unitTable
			MOVE.L	UTableBase,A1				; get the base of the unit table
			MOVE.L	(A1,D0),A3					; A3 = handle to the DCE
			MOVE.L	(A3),A1						; get pointer to the DCE

			LEA.L	-$D2(A6),A4
			LEA.L	-$82(A6),A0
			MOVE.L	A4,$1C(A0)
			MOVE	$18(A1),$18(A0)
			MOVE	#$A,$1A(A0)
			CLR.L	$C(A0)
			CLR.L	$12(A0)
			CLR		$16(A0)
			DC.W	$A205						; _PBStatusImmed
			BNE.S	@nope
			MOVE.L	$2(A4),-$3E(A6)
			MOVE.L	$8(A4),-$42(A6)
			MOVE.L	$2A(A1),D3
			LEA.L	-$AC(A6),A0
			LEA.L	-$C2(A6),A4
			MOVE.L	A0,$6(A4)
			MOVE.L	$10(A6),D0
			MOVE	D0,$4(A4)
			MOVE.L	-$3E(A6),(A4)
			LEA.L	-$82(A6),A0
			MOVE.L	A4,$1C(A0)
			MOVE	$14(A6),$18(A0)
			MOVE	#$12,$1A(A0)
			CLR.L	$C(A0)
			CLR.L	$12(A0)
			CLR		$16(A0)
			DC.W	$A205						; _PBStatusImmed
			BNE.S	@nope
			LEA.L	-$C2(A6),A4
			MOVE.B	#$1,-$D3(A6)
			MOVE.L	-$42(A6),D3
			MOVE.L	D3,$2A(A1)
			MOVE.L	$8(A6),A1
			MOVE.L	$E(A4),D4
			MOVE	D4,(A1)
			LEA.L	-$38(A6),A0
			LEA.L	-$AC(A6),A1
			BRA.S	@saveVals
@nope

; get the resource list for the specified device

			LEA		MYBLOCK(A6),A0				; point to parameter block
			MOVE.B	dCtlSlot(A1),spSlot(A0)		; get slot number
			MOVE.B	dCtlSlotID(A1),spID(A0)		; get ID
			MOVE.B	dCtlExtDev(A1),spExtDev(A0)	; External Device ID
			_sRsrcInfo							; get a pointer to the sResource list. <Cxxx>
			BNE		BadSlot						; => something wrong

; BaseAddr := dctlDevBase + MBaseOffset(Added later)								<C887 09Sep87 GWN>
	      	MOVE.L	dCtlDevBase(A1),D3			; Get the 24-bit base address.		<C887 09Sep87 GWN>

			MOVE.L	MODE(A6),D0					; get the mode
			MOVE.B	D0,spId(A0)					; pass the requested mode
			_sFindStruct						; get pointer to list for that mode
			BNE		BadSlot						; => something wrong
			MOVE.L	spsPointer(A0),A4			; A4 = pointer to list for that mode


; get devType

			MOVE	#CLUTType,D4				; assume device type = CLUT
			MOVE.B	#mDevType,spId(A0)			; device type
			_sReadWord							; go read it
			BNE.S	@CLUT						; => if none, assume CLUT
			MOVE	spResult+2(A0),D4			; get device type
@CLUT		MOVE.L	DEVTYPE(A6),A1				; get pointer to device type
			MOVE	D4,(A1)						; return device type

; get video parameter sBlock and save values as needed									<C742>

			MOVE.B	#mVidParams,spId(A0)		; get the parameters					<C742>
			_sGetBlock							; (in sBlock form)						<C742>
			BNE		BadSlot						; => something wrong
			MOVE.L	spResult(A0),A1				; save the pointer to the block			<C742>

@saveVals
			ADD.L	vpBaseOffset(A1),D3			; calculate baseAddr
			MOVE.L	D3,(A2)+					; save baseAddr


; get rowbytes, bounds, and version.

			MOVE.W	vpRowBytes(A1),D0			; Number of bytes between scan lines.	<C742>
			OR		#PMFlag,D0					; set pixMap flag
			MOVE	D0,(A2)+					; save rowbytes

			MOVE.L	vpBounds(A1),(A2)+			; read into our bounds					<C742>
			MOVE.L	vpBounds+4(A1),(A2)+		; rect is eight bytes					<C742>

			MOVE.W	vpVersion(A1),(A2)+			; pixMap version number					<C742>

		if ADDRMODEFLAG then					;										<BAL 11Dec88>

			tst.w	vpVersion(a1)				; is it standard?						<BAL 11Dec88>
			bne.s	@useTheirs					; no, leave it alone					<BAL 11Dec88>
			move.w	#fAddr32clean,-2(a2)		; yes, set 32 bit addressing flag		<BAL 11Dec88>
@useTheirs

		endif

; clear packType, packSize fields

			CLR		(A2)+						; packType := 0
			CLR.L	(A2)+						; packSize := 0


; get hRes, vRes, pixelType, pixelSize, cmpType, cmpSize and planebytes.

			MOVE.L	vpHRes(A1),(A2)+			; horizontal resolution					<C742>
			MOVE.L	vpVRes(A1),(A2)+			; vertical resolution					<C742>

			MOVE.W	vpPixelType(A1),(A2)+		; the pixel type						<C742>
			MOVE.W	vpPixelSize(A1),D5			; D5 = pixel size						<C742>
			MOVE.W	D5,(A2)+					; the pixel size						<C742>

			MOVE.W	vpCmpCount(A1),(A2)+		; the component count					<C742>
			MOVE.W	vpCmpSize(A1),(A2)+			; the component size					<C742>

			MOVE.L	vpPlaneBytes(A1),(A2)+		; offset from one plane to another		<C742>

; dispose of the sBlock																	<C742>
			TST.B	-$D3(A6)
			BNE.S	@dont
			MOVE.L	A1,spsPointer(A0)			;										<C742>
			_SDisposePtr						;										<C742>
			MOVE.L	A4,spsPointer(A0)			; restore pointer to list				<C742>
@dont

; use DevType to initialize the color table

			CMP		#FixedType,D4				; is it fixed?
			BEQ.S	GetFromSlot					; =>yes, get from card
			CMP		#CLUTType,D4				; is it color lookup?
			BNE.S	DirectCLUT					; =>no, must be direct; get unique seed	<BAL 07Jul88>

; Load in the color table and copy it to our handle.

GetClut		CLR.L	-(SP)						; make room for function result
			MOVE	D5,-(SP)					; push resource ID
			JSR		([$1660])					; load in the color table resource
			MOVE.L	(SP)+,D0					; did we get one?						<C769>
			BEQ		TableOK						; => no, just punt						<BAL 04Sep88>
			MOVE.L	D0,-(SP)					; push new handle for dispose			<C1/9>
			MOVE.L	D0,-(SP)					; push source handle					<C1/9>
			MOVE.L	(A2),-(SP)					; push destination handle				<C1/9>
			JSR		([$1A14])					; copy table into our handle
			JSR		([$1690])					; and dispose of new color table
			BRA.S	TableOK						; => and continue

;
; Read the color table from the ROM.  This code is a little different than it's ancestor.	<2.3>
;	Rather than expecting a cSpecArray, this expects that mTable points to a color table
;	image (including header).  It's not bad to change this since there was a bug that
;	prevented it from working at all before (spSize had been read as a word, rather than
;	long, so it would never make the correct calculation).  Get the fixed color table as
;	a pointer, put in a new ctSeed, then make the pointer into a handle.
;

GetFromSlot	MOVE.B	#mTable,spID(A0)			; the fixed table							<2.3>
			_SReadPBSize						; find the table and get it's size			<2.3>
			BNE.S	GetClut						; => something wrong, use default table		<2.3>

			SUB.L	#4,spSize(A0)				; adjust for slot block header				<2.3>
			MOVE.L	spSize(A0),D0				; get size of table							<2.3>
			MOVE.L	(A2),A0						; get existing color table handle			<2.3>
			_SetHandleSize						; set it to the new size					<2.3>

			MOVE.L	(A0),A1						; deref handle								<2.3>

			LEA		MYBLOCK(A6),A0				; point to parameter block
			MOVE.L	A1,spResult(A0)				; put handle in destination					<2.3>
			_sReadStruct						; read the table from the ROM				<2.3>

;••• <SM3> CSS rollin patch GetDevPixMapPatch from horror
			MOVE.L	ctSeed(A1),D0				; get the current seed						<H2>
			BEQ.S	@GetNewSeed					; -> it's zero, so generate a new one		<H2>
			CMPI.L	#minSeed,D0					; is it a resource ID?						<H2>
			BLE.S	@UseOriginalSeed			; -> yes, assume we know what we're doing	<H2>
@GetNewSeed	SUBQ	#4,SP						; make room for function result				<2.3>
			JSR		([$16A0])					; get a new, unique ctable seed
			MOVE.L	(SP)+,ctSeed(A1)			; put in the new seed						<2.3>
@UseOriginalSeed
												;   transindex/ctflags set below			<2.3>

;••• <SM3> CSS end rollin GetDevPixMapPatch from Horror

			MOVE.L	A4,spsPointer(A0)			; Restore the pointer to mode list.			<C742>
			bra.s	TableOK

DirectCLUT										; Set up fake CLUT for direct devices 	<BAL 07Jul88>
			MOVE.L	PMH(A6),A0					; get handle to pixMap
			move.l	(a0),a0						; get pixMap ptr
			move	cmpSize(a0),d0				;
			mulu	cmpCount(a0),d0				; compute seed value
			move.l	pmTable(A0),a0				; get clut handle
			move.l	(a0),a0						; clut ptr
			move.l	d0,(a0)						; set up seed


TableOK		move.l	(a2),a0						; get pmTable			<BAL 29Mar89>
			move.l	(a0),a0						; get ptr to clut		<BAL 29Mar89>
			move.w	#$8000,TransIndex(a0)		; set Device clut flag	<BAL 29Mar89>
			ADDQ	#4,A2						; skip over table
			CLR.L	(A2)+						; clear pmReserved

; Error, bad video card.

BadSlot
DONE		MOVE.L	PMH(A6),A0					; get handle to pixMap
			MOVE	PMHState(A6),D0				; get prior state
			_HSetState							; restore lock state

GOHOME		MOVEM.L	(SP)+,D3-D5/A2-A4			; restore work registers
			UNLINK	PARAMSIZE,'GETDEVPI'


GoBadSlot	ADDQ	#4,SP						; strip pointer off stack
			BRA.S	BadSlot						; and return with error

	ENDWITH


CheckDevices	PROC	EXPORT

				WITH		VDPageInfo			;<1.1>

				IMPORT	CopyHandle
;----------------------------------------------------------
;
;  PROCEDURE CheckDevices;
;
;  Look at the device list to see if it needs to be initialized.  If so, read
;  in the resource of type 'scrn'.  If it is found, configure the devices as
;  described in that resource.  The format of the 'scrn' resource is:
;
;  [count]					; [word] number of devices in resource
;  FOR I := 1 TO COUNT DO
;	 [sResource Type]		; [word] spDrvrH of device n
;	 [slot]					; [word] slot number of device n
;	 [dCtlDevBase]			; [long] the dCtlDevBase of device n
;	 [mode]					; [word] the sRsrcID for the desired mode
;	 [flagMask]				; [word] masks off all bits used in flags
;	 [flags]				; [word] indicates the state of the device
;							;		 	bit 0 = 0 if monochrome; 1 if color
;							;			bit 11 = 1 if this device is main screen
;							;			bit 15 = 1 if the screen is active
;	 [colorTable]			; [word] resource id of desired color table (-1=none)
;	 [gammaTable]			; [word] resource id of gamma table (-1=none)
;	 [global Rect]			; [rect] global rectangle for this device
;	 [CtlCount]				; [word] number of control calls following
;	 FOR J := 1 TO CtlCount DO
;		[csCode]			; [word] control code for this call
;		[length]			; [word] number of bytes in the param blk
;		[param blk]			; [length] data to be passed in control call
;	 END;
;  END;
;
;  CheckDevices is called by InitGraf.


		RTS

;-------------------------------------------------------------
;
;  ROUTINES FOR ACCESSING THE DEVICE LIST
;


GetGDevice	PROC	EXPORT
;----------------------------------------------------------
;
;  FUNCTION GetGDevice: GDHandle;
;
;  Return the handle to the current device
;
		MOVE.L	(SP)+,A0					; get return address
		MOVE.L	theGDevice,(SP)				; return device handle
		JMP		(A0)						; and return



SetGDevice	PROC	EXPORT
;----------------------------------------------------------
;
;  PROCEDURE SetGDevice (GDH: GDHandle);
;
;  Set the device specifed in GDH to be the current device
;
;  This routine needs to close the current video device if
;  there is one, then it should open the new one.  It should
;  also call the device to let it set up anything it might
;  need to set up (e.g. change the bottleneck procs).
;
		MOVE.L	(SP)+,A0					; get the return address
		MOVE.L	(SP)+,theGDevice			; set the specified handle
		JMP		(A0)						; and return



GETDEVICELIST	PROC	EXPORT
;-------------------------------------------------------------
;
;  FUNCTION GETDEVICELIST: GDHandle;
;
;  RETURNS A HANDLE TO THE FIRST ELEMENT IN THE DEVICE LIST
;
			MOVE.L	(SP)+,A0					; GET RETURN ADDRESS
			MOVE.L	DeviceList,(SP)				; RETURN DEVICE LIST
			JMP		(A0)						; AND RETURN



GETMAINDEVICE	PROC	EXPORT
;-------------------------------------------------------------
;
;  FUNCTION GETMAINDEVICE: GDHandle;
;
;  RETURNS A HANDLE TO THE MAIN SCREEN DEVICE
;
			MOVE.L	(SP)+,A0					; GET RETURN ADDRESS
			MOVE.L	MainDevice,(SP)				; RETURN DEVICE LIST
			JMP		(A0)						; AND RETURN



GETNEXTDEVICE	PROC	EXPORT
;-------------------------------------------------------------
;
;  FUNCTION GETNEXTDEVICE(GDH: GDHandle): GDHandle;
;
;  RETURNS A HANDLE TO THE NEXT SCREEN DEVICE
;  IF THERE IS NO NEXT DEVICE, RETURNS NIL
;
			MOVE.L	(SP)+,A0					; GET RETURN ADDRESS
			MOVE.L	(SP)+,A1					; GET GDH
			MOVE.L	(A1),A1						; POINT TO DEVICE
			MOVE.L	GDNextGD(A1),(SP)			; RETURN NEXT DEVICE
			JMP		(A0)						; AND RETURN


TestDeviceAttribute	PROC	EXPORT
;-------------------------------------------------------------
;
;  FUNCTION TestDeviceAttribute(GDH: GDHandle; attribute: INTEGER): BOOLEAN;
;
;  Tests the specified attribute, returns TRUE if attribute is true
;
			MOVE.L	(SP)+,A1					; GET RETURN ADDRESS
			MOVE	(SP)+,D0					; GET ATTRIBUTE
			MOVE.L	(SP)+,A0					; GET GDH
			CLR.B	(SP)						; ASSUME FALSE
			MOVE.L	(A0),A0						; POINT TO DEVICE
			MOVE	GDFlags(A0),D1				; GET FLAGS WORD
			BTST	D0,D1						; TEST ATTRIBUTE
			BEQ.S	IsFalse						; => ATTRIBUTE NOT SET
			ADD.B	#1,(SP)						; ELSE RETURN TRUE
IsFalse		JMP		(A1)						; AND RETURN



SetDeviceAttribute	PROC	EXPORT
;-------------------------------------------------------------
;
;  PROCEDURE SetDeviceAttribute(GDH: GDHandle; attribute: INTEGER; state: Boolean);
;
;  Sets the specified attribute to true or false
;
			MOVE.L	(SP)+,A1					; GET RETURN ADDRESS
			MOVE.B	(SP)+,D0					; GET BOOLEAN
			MOVE	(SP)+,D1					; GET ATTRIBUTE
			MOVE.L	(SP)+,A0					; GET GDH
			MOVE.L	(A0),A0						; POINT TO DEVICE
			MOVE	GDFLAGS(A0),D2				; GET FLAGS WORD
			TST.B	D0							; TEST BOOLEAN
			BNE.S	SetIt						; =>SET FLAG
			BCLR	D1,D2						; CLEAR ATTRIBUTE
			BRA.S	SDAShare					; RETURN VALUE AND RETURN
SetIt		BSET	D1,D2						; SET ATTRIBUTE
SDAShare	MOVE	D2,GDFLAGS(A0)				; RETURN IT
			JMP		(A1)						; AND RETURN


GETMAXDEVICE	PROC	EXPORT
;-------------------------------------------------------------
;
;  FUNCTION GETMAXDEVICE(r: Rect): GDHandle;
;
;  RETURNS A HANDLE TO THE DEEPEST SCREEN DEVICE
;  THAT INTERSECTS THE SPECIFIED GLOBAL RECTANGLE.
;
PARAMSIZE	EQU 	4							; TOTAL BYTES OF PARAMETERS
RESULT		EQU 	PARAMSIZE+8 				; LONG, GRAFDEVICE
RECT		EQU 	PARAMSIZE+8-4 				; LONG, ADDR OF GLOBAL RECTANGLE

DSTRECT		EQU		-8							; RECT, VAR FOR SECTRECT
VARSIZE		EQU		DSTRECT						; SIZE OF LOCALS

			LINK	A6,#VARSIZE					; ALLOCATE STACK FRAME
			MOVEM.L	D3/A3,-(SP)					; SAVE WORK REGISTERS
			CLR.L	RESULT(A6)					; ASSUME NO INTERSECTION
			MOVEQ	#0,D3						; MAX DEPTH = 0
			MOVE.L	DEVICELIST,A3				; GET FIRST ELEMENT IN DEVICE LIST

NEXTGD		MOVE.L	(A3),A0						; POINT TO DEVICE
			TST		GDFLAGS(A0)					; IS IT ACTIVE?
			BPL.S	SKIPGD						; =>NO, SKIP IT

			CLR.B	-(SP)						; MAKE ROOM FOR BOOLEAN RESULT
			MOVE.L	RECT(A6),-(SP)				; PUSH SPECIFIED RECTANGLE
			PEA		GDRECT(A0)					; PUSH DEVICE'S RECTANGLE
			PEA		DSTRECT(A6)					; PUSH DESTINATION RECT (IGNORED)
			_SECTRECT							; IS THE RECT IN THE DEVICE
			TST.B	(SP)+						; TEST RESULT
			BEQ.S	SKIPGD						; => NO INTERSECTION

			MOVE.L	(A3),A0						; POINT TO DEVICE
			MOVE.L	GDPMAP(A0),A0				; GET PIXMAP
			MOVE.L	(A0),A0						; POINT TO PIXMAP
			MOVE	PIXELSIZE(A0),D0			; GET PIXEL DEPTH
			CMP		D3,D0						; COMPARE TO SAVED DEPTH
			BLE.S	SKIPGD						; => NO BIG DEAL
			MOVE	D0,D3						; ELSE UPDATE MAX DEPTH
			MOVE.L	A3,RESULT(A6)				; AND RETURN RESULT

SKIPGD		MOVE.L	(A3),A0						; GET DEVICE
			MOVE.L	GDNEXTGD(A0),D0				; GET NEXT DEVICE
			MOVE.L	D0,A3						; SAVE IT
			BNE.S	NEXTGD

			MOVEM.L	(SP)+,D3/A3					; RESTORE WORK REGISTERS
			UNLINK	PARAMSIZE,'GETMAXDE'		; STRIP PARAMS AND RETURN



GETDEVPIX	PROC	EXPORT
;-------------------------------------------------------------
;
;  UTILITY GetDevPix;
;
;  Returns a pointer to theGDevice's pixMap in A0
;
			MOVE.L	theGDevice,A0				; GET A HANDLE TO THE GRAFDEVICE
			MOVE.L	(A0),A0						; GET A POINTER TO THE GRAFDEVICE
			MOVE.L	GDPMAP(A0),A0				; GET HANDLE TO THE DEVICE'S PIXMAP
SHARE		MOVE.L	(A0),A0						; GET PIXMAP POINTER
			RTS



